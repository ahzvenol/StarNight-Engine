// Generated by dts-bundle-generator v6.11.0

import type { Matrix, ObservablePoint, Point, Renderer, Texture, Ticker, FederatedPointerEvent } from 'pixi.js'
import { Transform, Container } from 'pixi.js'

declare class Live2DModelWebGL {
    static loadModel(buffer: ArrayBuffer): Live2DModelWebGL
    private constructor()
    drawParamWebGL: Live2DObfuscated.DrawParamWebGL
    getModelContext(): Live2DObfuscated.ModelContext
    /**
	 * @return The width of model's Live2D drawing canvas but NOT the html canvas element.
	 */
    getCanvasWidth(): number
    /**
	 * @return The height of model's Live2D drawing canvas but NOT the html canvas element.
	 */
    getCanvasHeight(): number
    setTexture(index: number, texture: WebGLTexture): void
    setMatrix(matrix: ArrayLike<number>): void
    setParamFloat(id: string | number, value: number, weight?: number): unknown
    addToParamFloat(id: string | number, value: number, weight?: number): unknown
    multParamFloat(id: string | number, value: number, weight?: number): unknown
    setPartsOpacity(id: string | number, value: number): unknown
    getPartsOpacity(id: string | number): number
    getParamFloat(id: string | number): number
    getParamIndex(id: string): number
    getPartsDataIndex(id: string): number
    getDrawDataIndex(id: string): number
    getTransformedPoints(index: number): Float32Array
    loadParam(): void
    saveParam(): void
    update(): void
    draw(): void
}
declare class AMotion {
    setFadeIn(time: number): unknown
    setFadeOut(time: number): unknown
    updateParam(model: Live2DModelWebGL, entry: Live2DObfuscated.MotionQueueEnt): void
    updateParamExe(model: Live2DModelWebGL, time: number, weight: number, MotionQueueEnt: unknown): unknown
}
declare class Live2DMotion extends AMotion {
    private constructor()
    static loadMotion(buffer: ArrayBuffer): Live2DMotion
}
declare class MotionQueueManager {
    motions: unknown[]
    /**
	 * @return The size of internal motion arrays.
	 */
    startMotion(motion: AMotion, neverUsedArg?: boolean): number
    stopAllMotions(): void
    isFinished(): boolean
    /**
	 * @return True if parameters are updated by any motion.
	 */
    updateParam(model: Live2DModelWebGL): boolean
}
declare class PhysicsHair {
    static Src: {
        SRC_TO_X: string,
        SRC_TO_Y: string,
        SRC_TO_G_ANGLE: string
    }
    static Target: {
        TARGET_FROM_ANGLE: string,
        TARGET_FROM_ANGLE_V: string
    }
    setup(length: number, regist: number, mass: number): unknown
    addSrcParam(type: string, id: string, scale: number, weight: number): unknown
    addTargetParam(type: string, id: string, scale: number, weight: number): unknown
    update(model: Live2DModelWebGL, time: number): unknown
}
declare class DrawDataID {
    id: string
}
/**
 * Members that have been obfuscated.
 */
export declare namespace Live2DObfuscated {
    class MotionQueueEnt {
        isFinished(): boolean
    }
    class DrawParamWebGL {
        gl: WebGLRenderingContext
        glno: number
        firstDraw: boolean
        culling: boolean
        setGL(gl: WebGLRenderingContext): void
    }
    class ModelContext {
        clipManager: ClipManager
        /**
		 * This is basically `DrawData[]`, but not reliable since it's an obfuscated property.
		 * Always check the type before using it!
		 */
        _$aS?: unknown // DrawData[]
        getDrawData(index: number): DrawData | null
    }
    class IDrawData {
        getDrawDataID(): DrawDataID
    }
    class DrawData extends IDrawData {
        getNumPoints?(): unknown
        draw(aN: unknown, aK: unknown, aI: Unknown_aB): void
    }
    class Unknown_aB {
        baseOpacity: number
    }
    class ClipManager {
        curFrameNo: number
        getMaskRenderTexture(): number
        setupClip(modelContext: ModelContext, drawParam: DrawParamWebGL): void
    }
}
/**
 * Copyright(c) Live2D Inc. All rights reserved.
 *
 * Use of this source code is governed by the Live2D Proprietary Software license
 * that can be found at https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.html.
 */
export declare namespace Live2DCubismCore {
	/** Cubism version identifier. */
	type csmVersion = number
	/** moc3 version identifier. */
	type csmMocVersion = number
	/** Parameter type identifier. */
	type csmParameterType = number
	/** Necessary alignment for mocs (in bytes). */
	const AlignofMoc: number
	/** Necessary alignment for models (in bytes). */
	const AlignofModel: number
	/** .moc3 file version Unknown */
	const MocVersion_Unknown: number
	/** .moc3 file version 3.0.00 - 3.2.07 */
	const MocVersion_30: number
	/** .moc3 file version 3.3.00 - 3.3.03 */
	const MocVersion_33: number
	/** .moc3 file version 4.0.00 - 4.1.05 */
	const MocVersion_40: number
	/** .moc3 file version 4.2.00 - */
	const MocVersion_42: number
	/** Normal Parameter. */
	const ParameterType_Normal: number
	/** Parameter for blend shape. */
	const ParameterType_BlendShape: number
	/** Log handler.
	 *
	 * @param message Null-terminated string message to log.
	 */
	interface csmLogFunction {
	    (message: string): void
	}
	/** Cubism version. */
	class Version {
	    /**
		 * Queries Core version.
		 *
		 * @return Core version.
		 */
	    static csmGetVersion(): csmVersion
	    /**
		 * Gets Moc file supported latest version.
		 *
		 * @return Moc file latest format version.
		 */
	    static csmGetLatestMocVersion(): csmMocVersion
	    /**
		 * Gets Moc file format version.
		 *
		 * @param moc Moc
		 *
		 * @return csmMocVersion
		 */
	    static csmGetMocVersion(moc: Moc, mocBytes: ArrayBuffer): csmMocVersion
	    private constructor()
	}
	/** Cubism logging. */
	class Logging {
	    private static logFunction
	    /**
		 * Sets log handler.
		 *
		 * @param handler  Handler to use.
		 */
	    static csmSetLogFunction(handler: csmLogFunction): void
	    /**
		 * Queries log handler.
		 *
		 * @return Log handler.
		 */
	    static csmGetLogFunction(): csmLogFunction
	    /**
		 * Wrap log function.
		 *
		 * @param messagePtr number
		 *
		 * @return string
		 */
	    private static wrapLogFunction
	    private constructor()
	}
	/** Cubism moc. */
	class Moc {
	    /**
		 * Checks consistency of a moc.
		 *
		 * @param mocBytes Moc bytes.
		 *
		 * @returns '1' if Moc is valid; '0' otherwise.
		 */
	    hasMocConsistency(mocBytes: ArrayBuffer): number
	    /** Creates [[Moc]] from [[ArrayBuffer]].
		 *
		 * @param buffer Array buffer
		 *
		 * @return [[Moc]] on success; [[null]] otherwise.
		 */
	    static fromArrayBuffer(buffer: ArrayBuffer): Moc
	    /** Releases instance. */
	    _release(): void
	    /** Native moc. */
	    _ptr: number
	    /**
		 * Initializes instance.
		 *
		 * @param mocBytes Moc bytes.
		 */
	    private constructor()
	}
	/** Cubism model. */
	class Model {
	    /** Parameters. */
	    parameters: Parameters
	    /** Parts. */
	    parts: Parts
	    /** Drawables. */
	    drawables: Drawables
	    /** Canvas information. */
	    canvasinfo: CanvasInfo
	    /**
		 * Creates [[Model]] from [[Moc]].
		 *
		 * @param moc Moc
		 *
		 * @return [[Model]] on success; [[null]] otherwise.
		 */
	    static fromMoc(moc: Moc): Model
	    /** Updates instance. */
	    update(): void
	    /** Releases instance. */
	    release(): void
	    /** Native model. */
	    _ptr: number
	    /**
		 * Initializes instance.
		 *
		 * @param moc Moc
		 */
	    private constructor()
	}
	/** Canvas information interface. */
	class CanvasInfo {
	    /** Width of native model canvas. */
	    CanvasWidth: number
	    /** Height of native model canvas. */
	    CanvasHeight: number
	    /** Coordinate origin of X axis. */
	    CanvasOriginX: number
	    /** Coordinate origin of Y axis. */
	    CanvasOriginY: number
	    /** Pixels per unit of native model. */
	    PixelsPerUnit: number
	    /**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model pointer.
		 */
	    constructor(modelPtr: number)
	}
	/** Cubism model parameters */
	class Parameters {
	    /** Parameter count. */
	    count: number
	    /** Parameter IDs. */
	    ids: Array<string>
	    /** Minimum parameter values. */
	    minimumValues: Float32Array
	    /** Parameter types. */
	    types: Int32Array
	    /** Maximum parameter values. */
	    maximumValues: Float32Array
	    /** Default parameter values. */
	    defaultValues: Float32Array
	    /** Parameter values. */
	    values: Float32Array
	    /** Number of key values of each parameter. */
	    keyCounts: Int32Array
	    /** Key values of each parameter. */
	    keyValues: Array<Float32Array>
	    /**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
	    constructor(modelPtr: number)
	}
	/** Cubism model parts */
	class Parts {
	    /** Part count. */
	    count: number
	    /** Part IDs. */
	    ids: Array<string>
	    /** Opacity values. */
	    opacities: Float32Array
	    /** Part's parent part indices. */
	    parentIndices: Int32Array
	    /**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
	    constructor(modelPtr: number)
	}
	/** Cubism model drawables */
	class Drawables {
	    /** Drawable count. */
	    count: number
	    /** Drawable IDs. */
	    ids: Array<string>
	    /** Constant drawable flags. */
	    constantFlags: Uint8Array
	    /** Dynamic drawable flags. */
	    dynamicFlags: Uint8Array
	    /** Drawable texture indices. */
	    textureIndices: Int32Array
	    /** Drawable draw orders. */
	    drawOrders: Int32Array
	    /** Drawable render orders. */
	    renderOrders: Int32Array
	    /** Drawable opacities. */
	    opacities: Float32Array
	    /** Mask count for each drawable. */
	    maskCounts: Int32Array
	    /** Masks for each drawable. */
	    masks: Array<Int32Array>
	    /** Number of vertices of each drawable. */
	    vertexCounts: Int32Array
	    /** 2D vertex position data of each drawable. */
	    vertexPositions: Array<Float32Array>
	    /** 2D texture coordinate data of each drawables. */
	    vertexUvs: Array<Float32Array>
	    /** Number of triangle indices for each drawable. */
	    indexCounts: Int32Array
	    /** Triangle index data for each drawable. */
	    indices: Array<Uint16Array>
	    /** Information multiply color. */
	    multiplyColors: Float32Array
	    /** Information Screen color. */
	    screenColors: Float32Array
	    /** Indices of drawables parent part. */
	    parentPartIndices: Int32Array
	    /** Resets all dynamic drawable flags.. */
	    resetDynamicFlags(): void
	    /** Native model. */
	    private _modelPtr
	    /**
		 * Initializes instance.
		 *
		 * @param modelPtr Native model.
		 */
	    constructor(modelPtr: number)
	}
	/** Utility functions. */
	class Utils {
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasBlendAdditiveBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasBlendMultiplicativeBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasIsDoubleSidedBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasIsInvertedMaskBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasIsVisibleBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasVisibilityDidChangeBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasOpacityDidChangeBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasDrawOrderDidChangeBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasRenderOrderDidChangeBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasVertexPositionsDidChangeBit(bitfield: number): boolean
	    /**
		 * Checks whether flag is set in bitfield.
		 *
		 * @param bitfield Bitfield to query against.
		 *
		 * @return [[true]] if bit set; [[false]] otherwise
		*/
	    static hasBlendColorDidChangeBit(bitfield: number): boolean
	}
	/** Memory functions. */
	class Memory {
	    /**
		 * HACK:
		 * Extend memory size allocated during module initialization.
		 * If the specified size is less than or equal to 16777216(byte), the default of 16 MB is allocated.
		 *
		 * @see https://github.com/emscripten-core/emscripten/blob/main/src/settings.js#L161
		 *
		 * @param size allocated memory size [byte(s)]
		 */
	    static initializeAmountOfMemory(size: number): void
	    private constructor()
	}
	/** Emscripten Cubism Core module. */
}
export declare const LOGICAL_WIDTH = 2
export declare const LOGICAL_HEIGHT = 2
export type JSONObject = object
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
}
/**
 * Parses, and provides access to the settings JSON.
 */
export declare abstract class ModelSettings {
    json: JSONObject
    /**
	 * The model's name, typically used for displaying or logging. By default it's inferred from
	 * the URL by taking the folder name (the second to last component). In Cubism 2 it'll be overwritten
	 * by the `name` field of settings JSON.
	 */
    name: string
    /**
	 * URL of the model settings file, used to resolve paths of the resource files defined in settings.
	 * This typically ends with `.model.json` in Cubism 2 and `.model3.json` in Cubism 4.
	 */
    url: string
    /**
	 * Relative path of he moc file, typically ends with `.moc` in Cubism 2 and `.moc3` in Cubism 4.
	 */
    abstract moc: string
    /**
	 * Relative paths of the texture images.
	 */
    abstract textures: string[]
    /**
	 * Relative path of the pose file.
	 */
    pose?: string
    /**
	 * Relative path of the physics file.
	 */
    physics?: string
    /**
	 * @param json - The settings JSON object.
	 * @param json.url - The `url` field must be defined to specify the settings file's URL.
	 */
    protected constructor(json: JSONObject & {
        url: string
    })
    /**
	 * Resolves a relative path using the {@link url}. This is used to resolve the resource files
	 * defined in the settings.
	 * @param path - Relative path.
	 * @return Resolved path.
	 */
    resolveURL(path: string): string
    /**
	 * Replaces the resource files by running each file through the `replacer`.
	 * @param replacer - Invoked with two arguments: `(file, path)`, where `file` is the file definition,
	 * and `path` is its property path in the ModelSettings instance. A string must be returned to be the replacement.
	 *
	 * ```js
	 * modelSettings.replaceFiles((file, path) => {
	 *     // file = "foo.moc", path = "moc"
	 *     // file = "foo.png", path = "textures[0]"
	 *     // file = "foo.mtn", path = "motions.idle[0].file"
	 *     // file = "foo.motion3.json", path = "motions.idle[0].File"
	 *
	 *     return "bar/" + file;
	 * });
	 * ```
	 */
    replaceFiles(replacer: (file: string, path: string) => string): void
    /**
	 * Retrieves all resource files defined in the settings.
	 * @return A flat array of the paths of all resource files.
	 *
	 * ```js
	 * modelSettings.getDefinedFiles();
	 * // returns: ["foo.moc", "foo.png", ...]
	 * ```
	 */
    getDefinedFiles(): string[]
    /**
	 * Validates that the files defined in the settings exist in given files. Each file will be
	 * resolved by {@link resolveURL} before comparison.
	 * @param files - A flat array of file paths.
	 * @return All the files which are defined in the settings and also exist in given files,
	 * *including the optional files*.
	 * @throws Error if any *essential* file is defined in settings but not included in given files.
	 */
    validateFiles(files: string[]): string[]
}
/**
 * Indicates the motion priority.
 */
export declare enum MotionPriority {
    /** States that the model is currently not playing any motion. This priority cannot be applied to a motion. */
    NONE = 0,
    /** Low priority, used when starting idle motions automatically. */
    IDLE = 1,
    /** Medium priority. */
    NORMAL = 2,
    /** High priority. Motions as this priority will always be played regardless of the current priority. */
    FORCE = 3
}
/**
 * Handles the state of a MotionManager.
 */
export declare class MotionState {
    /**
	 * Tag for logging.
	 */
    tag: string
    /**
	 * When enabled, the states will be dumped to the logger when an exception occurs.
	 */
    debug: boolean
    /**
	 * Priority of the current motion. Will be `MotionPriority.NONE` if there's no playing motion.
	 */
    currentPriority: MotionPriority
    /**
	 * Priority of the reserved motion, which is still in loading and will be played once loaded.
	 * Will be `MotionPriority.NONE` if there's no reserved motion.
	 */
    reservePriority: MotionPriority
    /**
	 * Group of current motion.
	 */
    currentGroup?: string
    /**
	 * Index of current motion in its group.
	 */
    currentIndex?: number
    /**
	 * Group of the reserved motion.
	 */
    reservedGroup?: string
    /**
	 * Index of the reserved motion in its group.
	 */
    reservedIndex?: number
    /**
	 * Group of the reserved idle motion.
	 */
    reservedIdleGroup?: string
    /**
	 * Index of the reserved idle motion in its group.
	 */
    reservedIdleIndex?: number
    /**
	 * Reserves the playback for a motion.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return True if the reserving has succeeded.
	 */
    reserve(group: string, index: number, priority: MotionPriority): boolean
    /**
	 * Requests the playback for a motion.
	 * @param motion - The Motion, can be undefined.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied.
	 * @return True if the request has been approved, i.e. the motion is allowed to play.
	 */
    start(motion: any, group: string, index: number, priority: MotionPriority): boolean
    /**
	 * Notifies the motion playback has finished.
	 */
    complete(): void
    /**
	 * Sets the current motion.
	 */
    setCurrent(group: string | undefined, index: number | undefined, priority: MotionPriority): void
    /**
	 * Sets the reserved motion.
	 */
    setReserved(group: string | undefined, index: number | undefined, priority: MotionPriority): void
    /**
	 * Sets the reserved idle motion.
	 */
    setReservedIdle(group: string | undefined, index: number | undefined): void
    /**
	 * Checks if a Motion is currently playing or has reserved.
	 * @return True if active.
	 */
    isActive(group: string, index: number): boolean
    /**
	 * Resets the state.
	 */
    reset(): void
    /**
	 * Checks if an idle motion should be requests to play.
	 */
    shouldRequestIdleMotion(): boolean
    /**
	 * Checks if the model's expression should be overridden by the motion.
	 */
    shouldOverrideExpression(): boolean
    /**
	 * Dumps the state for debugging.
	 */
    dump(requestedGroup?: string, requestedIndex?: number): string
}
export interface MotionManagerOptions {
    /**
	 * How to preload the motions.
	 * @default {@link MotionPreloadStrategy.NONE}
	 */
    motionPreload?: MotionPreloadStrategy
    /**
	 * Specifies the idle motion group.
	 * @default "idle" in Cubism 2 and "Idle" in Cubism 4.
	 */
    idleMotionGroup?: string
}
/**
 * Indicates how the motions will be preloaded.
 */
export declare enum MotionPreloadStrategy {
    /** Preload all the motions. */
    ALL = 'ALL',
    /** Preload only the idle motions. */
    IDLE = 'IDLE',
    /** No preload. */
    NONE = 'NONE'
}
/**
 * Handles the motion playback.
 * @emits {@link MotionManagerEvents}
 */
export declare abstract class MotionManager<Motion = any, MotionSpec = any> extends utils.EventEmitter {
    /**
	 * Tag for logging.
	 */
    tag: string
    /**
	 * Motion definitions copied from ModelSettings.
	 */
    abstract readonly definitions: Partial<Record<string, MotionSpec[]>>
    /**
	 * Motion groups with particular internal usages. Currently there's only the `idle` field,
	 * which specifies the actual name of the idle motion group, so the idle motions
	 * can be correctly found from the settings JSON of various Cubism versions.
	 */
    abstract readonly groups: {
        idle: string
    }
    /**
	 * Indicates the content type of the motion files, varies in different Cubism versions.
	 * This will be used as `xhr.responseType`.
	 */
    abstract readonly motionDataType: 'json' | 'arraybuffer'
    /**
	 * Can be undefined if the settings defines no expression.
	 */
    abstract expressionManager?: ExpressionManager
    /**
	 * The ModelSettings reference.
	 */
    readonly settings: ModelSettings
    /**
	 * The Motions. The structure is the same as {@link definitions}, initially each group contains
	 * an empty array, which means all motions will be `undefined`. When a Motion has been loaded,
	 * it'll fill the place in which it should be; when it fails to load, the place will be filled
	 * with `null`.
	 */
    motionGroups: Partial<Record<string, (Motion | undefined | null)[]>>
    /**
	 * Maintains the state of this MotionManager.
	 */
    state: MotionState
    /**
	 * Audio element of the current motion if a sound file is defined with it.
	 */
    currentAudio?: HTMLAudioElement
    /**
	 * Analyzer element for the current sound being played.
	 */
    currentAnalyzer?: AnalyserNode
    /**
	 * Context element for the current sound being played.
	 */
    currentContext?: AudioContext
    /**
	 * Flags there's a motion playing.
	 */
    playing: boolean
    /**
	 * Flags the instances has been destroyed.
	 */
    destroyed: boolean
    protected constructor(settings: ModelSettings, options?: MotionManagerOptions)
    /**
	 * Should be called in the constructor of derived class.
	 */
    protected init(options?: MotionManagerOptions): void
    /**
	 * Sets up motions from the definitions, and preloads them according to the preload strategy.
	 */
    protected setupMotions(options?: MotionManagerOptions): void
    /**
	 * Loads a Motion in a motion group. Errors in this method will not be thrown,
	 * but be emitted with a "motionLoadError" event.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
	 * @emits {@link MotionManagerEvents.motionLoaded}
	 * @emits {@link MotionManagerEvents.motionLoadError}
	 */
    loadMotion(group: string, index: number): Promise<Motion | undefined>
    /**
	 * Loads the Motion. Will be implemented by Live2DFactory in order to avoid circular dependency.
	 * @ignore
	 */
    private _loadMotion
    /**
	 * Only play sound with lip sync
	 * @param sound - The audio url to file or base64 content
	 * ### OPTIONAL: {name: value, ...}
	 * @param volume - Volume of the sound (0-1)
	 * @param expression - In case you want to mix up a expression while playing sound (bind with Model.expression())
	 * @param resetExpression - Reset expression before and after playing sound (default: true)
	 * @param crossOrigin - Cross origin setting.
	 * @returns Promise that resolves with true if the sound is playing, false if it's not
	 */
    speak(sound: string, { volume, expression, resetExpression, crossOrigin, onFinish, onError }?: {
        volume?: number,
        expression?: number | string,
        resetExpression?: boolean,
        crossOrigin?: string,
        onFinish?: () => void,
        onError?: (e: Error) => void
    }): Promise<boolean>
    /**
	 * Starts a motion as given priority.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @param priority - The priority to be applied. default: 2 (NORMAL)
	 * ### OPTIONAL: {name: value, ...}
	 * @param sound - The audio url to file or base64 content
	 * @param volume - Volume of the sound (0-1)
	 * @param expression - In case you want to mix up a expression while playing sound (bind with Model.expression())
	 * @param resetExpression - Reset expression before and after playing sound (default: true)
	 * @param crossOrigin - Cross origin setting.
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
    startMotion(group: string, index: number, priority?: MotionPriority, { sound, volume, expression, resetExpression, crossOrigin, onFinish, onError }?: {
        sound?: string,
        volume?: number,
        expression?: number | string,
        resetExpression?: boolean,
        crossOrigin?: string,
        onFinish?: () => void,
        onError?: (e: Error) => void
    }): Promise<boolean>
    /**
	 * Starts a random Motion as given priority.
	 * @param group - The motion group.
	 * @param priority - The priority to be applied. (default: 1 `IDLE`)
	 * ### OPTIONAL: {name: value, ...}
	 * @param sound - The wav url file or base64 content+
	 * @param volume - Volume of the sound (0-1) (default: 1)
	 * @param expression - In case you want to mix up a expression while playing sound (name/index)
	 * @param resetExpression - Reset expression before and after playing sound (default: true)
	 * @return Promise that resolves with true if the motion is successfully started, with false otherwise.
	 */
    startRandomMotion(group: string, priority?: MotionPriority, { sound, volume, expression, resetExpression, crossOrigin, onFinish, onError }?: {
        sound?: string,
        volume?: number,
        expression?: number | string,
        resetExpression?: boolean,
        crossOrigin?: string,
        onFinish?: () => void,
        onError?: (e: Error) => void
    }): Promise<boolean>
    /**
	 * Stop current audio playback and lipsync
	 */
    stopSpeaking(): void
    /**
	 * Stops all playing motions as well as the sound.
	 */
    stopAllMotions(): void
    /**
	 * Updates parameters of the core model.
	 * @param model - The core model.
	 * @param now - Current time in milliseconds.
	 * @return True if the parameters have been actually updated.
	 */
    update(model: object, now: DOMHighResTimeStamp): boolean
    /**
	 * Move the mouth
	 *
	 */
    mouthSync(): number
    /**
	 * Destroys the instance.
	 * @emits {@link MotionManagerEvents.destroy}
	 */
    destroy(): void
    /**
	 * Checks if the motion playback has finished.
	 */
    abstract isFinished(): boolean
    /**
	 * Creates a Motion from the data.
	 * @param data - Content of the motion file. The format must be consistent with {@link MotionManager#motionDataType}.
	 * @param group - The motion group.
	 * @param definition - The motion definition.
	 * @return The created Motion.
	 */
    abstract createMotion(data: ArrayBuffer | JSONObject, group: string, definition: MotionSpec): Motion
    /**
	 * Retrieves the motion's file path by its definition.
	 * @return The file path extracted from given definition. Not resolved.
	 */
    abstract getMotionFile(definition: MotionSpec): string
    /**
	 * Retrieves the motion's name by its definition.
	 * @return The motion's name.
	 */
    protected abstract getMotionName(definition: MotionSpec): string
    /**
	 * Retrieves the motion's sound file by its definition.
	 * @return The motion's sound file, can be undefined.
	 */
    protected abstract getSoundFile(definition: MotionSpec): string | undefined
    /**
	 * Starts the Motion.
	 */
    protected abstract _startMotion(motion: Motion, onFinish?: (motion: Motion) => void): number
    /**
	 * Stops all playing motions.
	 */
    protected abstract _stopAllMotions(): void
    /**
	 * Updates parameters of the core model.
	 * @param model - The core model.
	 * @param now - Current time in milliseconds.
	 * @return True if the parameters have been actually updated.
	 */
    protected abstract updateParameters(model: object, now: DOMHighResTimeStamp): boolean
}
export interface Live2DModelEvents {
    /**
	 * @event - One or more hit areas are hit.
	 * @param - The names of *hit* hit areas.
	 */
    hit: [
        string[]
    ]
    /**
	 * @event - The settings JSON has been loaded.
	 * @param - The settings JSON object.
	 */
    settingsJSONLoaded: [
        JSONObject
    ]
    /**
	 * @event - The ModelSettings has been loaded.
	 * @param - The ModelSettings instance.
	 */
    settingsLoaded: [
        ModelSettings
    ]
    /**
	 * @event - The textures have all been loaded.
	 * @param - The texture array.
	 */
    textureLoaded: [
        Texture[]
    ]
    /**
	 * @event - The InternalModel has been loaded.
	 * @param - The InternalModel instance.
	 */
    modelLoaded: [
        InternalModel
    ]
    /**
	 * @event - The Pose has been loaded.
	 * @param - The Pose instance, varies in different Cubism version.
	 */
    poseLoaded: [
        unknown
    ]
    /**
	 * @event - The Physics has been loaded.
	 * @param - The Physics instance, varies in different Cubism version.
	 */
    physicsLoaded: [
        unknown
    ]
    /**
	 * @event - All the essential resources have been loaded.
	 */
    ready: [
    ]
    /**
	 * @event - All the resources have been loaded.
	 */
    load: [
    ]
}
export interface MotionManagerEvents<Motion = any> {
    /**
	 * @event - A Motion has been loaded.
	 * @param - The Motion instance, varies in different Cubism version.
	 */
    motionLoaded: [
        Motion
    ]
    /**
	 * @event - An error occurs when loading a Motion.
	 * @param - The error.
	 */
    motionLoadError: [
        unknown
    ]
    /**
	 * @event - Before destroyed.
	 */
    destroy: [
    ]
}
export interface ExpressionManagerEvents<Expression = any> {
    /**
	 * @event - An Expression has been loaded.
	 * @param - The Expression instance, varies in different Cubism version.
	 */
    expressionLoaded: [
        Expression
    ]
    /**
	 * @event - An error occurs when loading an Expression.
	 * @param - The error.
	 */
    expressionLoadError: [
        unknown
    ]
    /**
	 * @event - Before destroyed.
	 */
    destroy: [
    ]
}
export interface InternalModelEvents {
    /**
	 * @event - Before the model's parameters are updated by the motion.
	 */
    beforeMotionUpdate: [
    ]
    /**
	 * @event - After the model's parameters are updated by the motion.
	 */
    afterMotionUpdate: [
    ]
    /**
	 * @event - Before the model is updated with its parameters applied.
	 */
    beforeModelUpdate: [
    ]
    /**
	 * @event - Before destroyed.
	 */
    destroy: [
    ]
}
/**
 * Abstract expression manager.
 * @emits {@link ExpressionManagerEvents}
 */
export declare abstract class ExpressionManager<Expression = any, ExpressionSpec = any> extends utils.EventEmitter<keyof ExpressionManagerEvents> {
    /**
	 * Tag for logging.
	 */
    tag: string
    /**
	 * Expression definitions copied from ModelSettings.
	 */
    abstract readonly definitions: ExpressionSpec[]
    /**
	 * The ModelSettings reference.
	 */
    readonly settings: ModelSettings
    /**
	 * The Expressions. The structure is the same as {@link definitions}, initially there's only
	 * an empty array, which means all expressions will be `undefined`. When an Expression has
	 * been loaded, it'll fill the place in which it should be; when it fails to load,
	 * the place will be filled with `null`.
	 */
    expressions: (Expression | null | undefined)[]
    /**
	 * An empty Expression to reset all the expression parameters.
	 */
    defaultExpression: Expression
    /**
	 * Current Expression. This will not be overwritten by {@link ExpressionManager#defaultExpression}.
	 */
    currentExpression: Expression
    /**
	 * The pending Expression.
	 */
    reserveExpressionIndex: number
    /**
	 * Flags the instance has been destroyed.
	 */
    destroyed: boolean
    protected constructor(settings: ModelSettings, options?: MotionManagerOptions)
    /**
	 * Should be called in the constructor of derived class.
	 */
    protected init(): void
    /**
	 * Loads an Expression. Errors in this method will not be thrown,
	 * but be emitted with an "expressionLoadError" event.
	 * @param index - Index of the expression in definitions.
	 * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
	 * @emits {@link ExpressionManagerEvents.expressionLoaded}
	 * @emits {@link ExpressionManagerEvents.expressionLoadError}
	 */
    protected loadExpression(index: number): Promise<Expression | undefined>
    /**
	 * Loads the Expression. Will be implemented by Live2DFactory in order to avoid circular dependency.
	 * @ignore
	 */
    private _loadExpression
    /**
	 * Sets a random Expression that differs from current one.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
    setRandomExpression(): Promise<boolean>
    /**
	 * Resets model's expression using {@link ExpressionManager#defaultExpression}.
	 */
    resetExpression(): void
    /**
	 * Restores model's expression to {@link currentExpression}.
	 */
    restoreExpression(): void
    /**
	 * Sets an Expression.
	 * @param index - Either the index, or the name of the expression.
	 * @return Promise that resolves with true if succeeded, with false otherwise.
	 */
    setExpression(index: number | string): Promise<boolean>
    /**
	 * Updates parameters of the core model.
	 * @return True if the parameters are actually updated.
	 */
    update(model: object, now: DOMHighResTimeStamp): boolean
    /**
	 * Destroys the instance.
	 * @emits {@link ExpressionManagerEvents.destroy}
	 */
    destroy(): void
    /**
	 * Checks if the expression playback has finished.
	 */
    abstract isFinished(): boolean
    /**
	 * Retrieves the expression's index by its name.
	 * @return The index. `-1` if not found.
	 */
    abstract getExpressionIndex(name: string): number
    /**
	 * Retrieves the expression's file path by its definition.
	 * @return The file path extracted from given definition. Not resolved.
	 */
    abstract getExpressionFile(definition: ExpressionSpec): string
    /**
	 * Creates an Expression from the data.
	 * @param data - Content of the expression file.
	 * @param definition - The expression definition. Can be undefined in order to create {@link ExpressionManager#defaultExpression}.
	 * @return The created Expression.
	 */
    abstract createExpression(data: JSONObject, definition: ExpressionSpec | undefined): Expression
    /**
	 * Applies the Expression to the model.
	 */
    protected abstract _setExpression(motion: Expression): number
    /**
	 * Cancels expression playback.
	 */
    protected abstract stopAllExpressions(): void
    /**
	 * Updates parameters of the core model.
	 * @return True if the parameters are actually updated.
	 */
    protected abstract updateParameters(model: object, now: DOMHighResTimeStamp): boolean
}
/**
 * Interpolates the transition of focus position.
 */
export declare class FocusController {
    /** The focus position. */
    targetX: number
    /** The focus position. */
    targetY: number
    /** Current position. */
    x: number
    /** Current position. */
    y: number
    /** Current velocity. */
    vx: number
    /** Current velocity. */
    vy: number
    /**
	 * Sets the focus position.
	 * @param x - X position in range `[-1, 1]`.
	 * @param y - Y position in range `[-1, 1]`.
	 * @param instant - Should the focus position be instantly applied.
	 */
    focus(x: number, y: number, instant?: boolean): void
    /**
	 * Updates the interpolation.
	 * @param dt - Delta time in milliseconds.
	 */
    update(dt: DOMHighResTimeStamp): void
}
export declare const VOLUME = 0.5
/**
 * Manages all the sounds.
 */
export declare class SoundManager {
    /**
	 * Audio elements playing or pending to play. Finished audios will be removed automatically.
	 */
    static audios: HTMLAudioElement[]
    static analysers: AnalyserNode[]
    static contexts: AudioContext[]
    protected static _volume: number
    /**
	 * Global volume that applies to all the sounds.
	 */
    static get volume(): number
    static set volume(value: number)
    /**
	 * Creates an audio element and adds it to the {@link audios}.
	 * @param file - URL of the sound file.
	 * @param onFinish - Callback invoked when the playback has finished.
	 * @param onError - Callback invoked when error occurs.
	 * @param crossOrigin - Cross origin setting.
	 * @return Created audio element.
	 */
    static add(file: string, onFinish?: () => void, onError?: (e: Error) => void, crossOrigin?: string): HTMLAudioElement
    /**
	 * Plays the sound.
	 * @param audio - An audio element.
	 * @return Promise that resolves when the audio is ready to play, rejects when error occurs.
	 */
    static play(audio: HTMLAudioElement): Promise<void>
    static addContext(audio: HTMLAudioElement): AudioContext
    static addAnalyzer(audio: HTMLAudioElement, context: AudioContext): AnalyserNode
    /**
	 * Get volume for lip sync
	 * @param analyser - An analyzer element.
	 * @return Returns value to feed into lip sync
	 */
    static analyze(analyser: AnalyserNode): number
    /**
	 * Disposes an audio element and removes it from {@link audios}.
	 * @param audio - An audio element.
	 */
    static dispose(audio: HTMLAudioElement): void
    /**
	 * Destroys all managed audios.
	 */
    static destroy(): void
}
/**
 * Common layout definition shared between all Cubism versions.
 */
export interface CommonLayout {
    centerX?: number
    centerY?: number
    x?: number
    y?: number
    width?: number
    height?: number
    top?: number
    bottom?: number
    left?: number
    right?: number
}
/**
 * Common hit area definition shared between all Cubism versions.
 */
export interface CommonHitArea {
    id: string
    name: string
    index: number
}
export interface Bounds {
    x: number
    y: number
    width: number
    height: number
}
/**
 * 眨眼参数，毫秒
 */
export interface BlinkParam {
    blinkInterval: number
    blinkIntervalRandom: number
    closingDuration: number
    closedDuration: number
    openingDuration: number
}
export declare const baseBlinkParam: BlinkParam
export interface InternalModelOptions extends MotionManagerOptions {
}
/**
 * A wrapper that manages the states of a Live2D core model, and delegates all operations to it.
 * @emits {@link InternalModelEvents}
 */
export declare abstract class InternalModel extends utils.EventEmitter {
    /**
	 * The managed Live2D core model.
	 */
    abstract readonly coreModel: object
    abstract readonly settings: ModelSettings
    focusController: FocusController
    abstract motionManager: MotionManager
    pose?: any
    physics?: any
    /**
	 * Original canvas width of the model. Note this doesn't represent the model's real size,
	 * as the model can overflow from its canvas.
	 */
    readonly originalWidth: number
    /**
	 * Original canvas height of the model. Note this doesn't represent the model's real size,
	 * as the model can overflow from its canvas.
	 */
    readonly originalHeight: number
    /**
	 * Canvas width of the model, scaled by the `width` of the model's layout.
	 */
    readonly width: number
    /**
	 * Canvas height of the model, scaled by the `height` of the model's layout.
	 */
    readonly height: number
    /**
	 * Local transformation, calculated from the model's layout.
	 */
    localTransform: Matrix
    /**
	 * The final matrix to draw the model.
	 */
    drawingMatrix: Matrix
    /**
	 * The hit area definitions, keyed by their names.
	 */
    hitAreas: Record<string, CommonHitArea>
    /**
	 * Flags whether `gl.UNPACK_FLIP_Y_WEBGL` should be enabled when binding the textures.
	 */
    textureFlipY: boolean
    /**
	 * WebGL viewport when drawing the model. The format is `[x, y, width, height]`.
	 */
    viewport: [
        number,
        number,
        number,
        number
    ]
    /**
	 * Flags this instance has been destroyed.
	 */
    destroyed: boolean
    /**
	 * Should be called in the constructor of derived class.
	 */
    protected init(): void
    /**
	 * Sets up the model's size and local transform by the model's layout.
	 */
    protected setupLayout(): void
    /**
	 * Sets up the hit areas by their definitions in settings.
	 */
    protected setupHitAreas(): void
    /**
	 * Hit-test on the model.
	 * @param x - Position in model canvas.
	 * @param y - Position in model canvas.
	 * @return The names of the *hit* hit areas. Can be empty if none is hit.
	 */
    hitTest(x: number, y: number): string[]
    /**
	 * Hit-test for a single hit area.
	 * @param hitAreaName - The hit area's name.
	 * @param x - Position in model canvas.
	 * @param y - Position in model canvas.
	 * @return True if hit.
	 */
    isHit(hitAreaName: string, x: number, y: number): boolean
    /**
	 * Gets a drawable's bounds.
	 * @param index - Index of the drawable.
	 * @param bounds - Object to store the output values.
	 * @return The bounds in model canvas space.
	 */
    getDrawableBounds(index: number, bounds?: Bounds): Bounds
    /**
	 * Updates the model's transform.
	 * @param transform - The world transform.
	 */
    updateTransform(transform: Matrix): void
    /**
	 * Updates the model's parameters.
	 * @param dt - Elapsed time in milliseconds from last frame.
	 * @param now - Current time in milliseconds.
	 */
    update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void
    /**
	 * Destroys the model and all related resources.
	 * @emits {@link InternalModelEvents.destroy | destroy}
	 */
    destroy(): void
    /**
	 * Gets all the hit area definitions.
	 * @return Normalized definitions.
	 */
    protected abstract getHitAreaDefs(): CommonHitArea[]
    /**
	 * Gets the model's original canvas size.
	 * @return `[width, height]`
	 */
    protected abstract getSize(): [
        number,
        number
    ]
    /**
	 * Gets the layout definition.
	 * @return Normalized definition.
	 */
    protected abstract getLayout(): CommonLayout
    /**
	 * Gets all the drawables' IDs.
	 * @return IDs.
	 */
    abstract getDrawableIDs(): string[]
    /**
	 * Finds the index of a drawable by its ID.
	 * @return The index.
	 */
    abstract getDrawableIndex(id: string): number
    /**
	 * Gets a drawable's vertices.
	 * @param index - Either the index or the ID of the drawable.
	 * @throws Error when the drawable cannot be found.
	 */
    abstract getDrawableVertices(index: number | string): Float32Array
    /**
	 * Updates WebGL context bound to this model.
	 * @param gl - WebGL context.
	 * @param glContextID - Unique ID for given WebGL context.
	 */
    abstract updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void
    /**
	 * Binds a texture to the model. The index must be the same as that of this texture
	 * in the {@link ModelSettings.textures} array.
	 */
    abstract bindTexture(index: number, texture: WebGLTexture): void
    /**
	 * Draws the model.
	 */
    abstract draw(gl: WebGLRenderingContext): void
    abstract setBlinkParam(blinkParam: Partial<BlinkParam>): void
}
export type Middleware<T> = (context: T, next: (err?: any) => Promise<void>) => Promise<void>
export interface Live2DFactoryOptions extends Live2DModelOptions {
    /**
	 * Whether to check the consistency of the moc file. It's an internal
	 * function of Cubism core and only available since Cubism 4 R7.
	 * @default false
	 */
    checkMocConsistency?: boolean
    /**
	 * String to use for crossOrigin properties on `<img>` elements when loading textures.
	 * @default undefined
	 */
    crossOrigin?: string
    /**
	 * Callback invoked when the model has been loaded.
	 * @default undefined
	 */
    onLoad?(): void
    /**
	 * Callback invoked when error occurs while loading the model.
	 * @default undefined
	 */
    onError?(e: Error): void
}
/**
 * The context transferred through the model creation middlewares.
 */
export interface Live2DFactoryContext {
    source: any
    options: Live2DFactoryOptions
    live2dModel: Live2DModel
    internalModel?: InternalModel
    settings?: ModelSettings
}
/**
 * Represents a Cubism version.
 */
export interface Live2DRuntime {
    /**
	 * The version number. Higher version takes priority when matching the runtime.
	 */
    version: number
    /**
	 * Checks if the source belongs to this runtime.
	 * @param source - Either a settings JSON object or a ModelSettings instance.
	 * @return True if the source belongs to this runtime.
	 */
    test(source: any): boolean
    ready(): Promise<void>
    /**
	 * Checks if the data is a valid moc to create the core model.
	 * @param modelData - The moc content.
	 * @return True if the data is valid.
	 */
    isValidMoc(modelData: ArrayBuffer): boolean
    /**
	 * Creates a ModelSettings.
	 * @param json - The settings JSON object.
	 * @return Created ModelSettings.
	 */
    createModelSettings(json: JSONObject): ModelSettings
    /**
	 * Creates a core model.
	 * @param data - Content of the moc file.
	 * @return Created core model.
	 */
    createCoreModel(data: ArrayBuffer, options?: Live2DFactoryOptions): any
    /**
	 * Creates an InternalModel.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param settings - ModelSettings of this model.
	 * @param options - Options that will be passed to the InternalModel's constructor.
	 * @return Created InternalModel.
	 */
    createInternalModel(coreModel: any, settings: ModelSettings, options?: Live2DFactoryOptions): InternalModel
    /**
	 * Creates a pose.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param data - Content of the pose file.
	 * @return Created pose.
	 */
    createPose(coreModel: any, data: any): any
    /**
	 * Creates a physics.
	 * @param coreModel - Core model that *must* belong to this runtime.
	 * @param data - Content of the physics file.
	 * @return Created physics.
	 */
    createPhysics(coreModel: any, data: any): any
}
/**
 * Handles all the network load tasks.
 *
 * - Model creation: requested by {@link Live2DModel.from}.
 * - Motion loading: implements the load method of MotionManager.
 * - Expression loading: implements the load method of ExpressionManager.
 */
export declare class Live2DFactory {
    /**
	 * All registered runtimes, sorted by versions in descending order.
	 */
    static runtimes: Live2DRuntime[]
    static urlToJSON: Middleware<Live2DFactoryContext>
    static jsonToSettings: Middleware<Live2DFactoryContext>
    static waitUntilReady: Middleware<Live2DFactoryContext>
    static setupOptionals: Middleware<Live2DFactoryContext>
    static setupEssentials: Middleware<Live2DFactoryContext>
    static createInternalModel: Middleware<Live2DFactoryContext>
    /**
	 * Middlewares to run through when setting up a Live2DModel.
	 */
    static live2DModelMiddlewares: Middleware<Live2DFactoryContext>[]
    /**
	 * load tasks of each motion. The structure of each value in this map
	 * is the same as respective {@link MotionManager.definitions}.
	 */
    static motionTasksMap: WeakMap<MotionManager<any, any>, Record<string, (Promise<any> | undefined)[]>>
    /**
	 * Load tasks of each expression.
	 */
    static expressionTasksMap: WeakMap<ExpressionManager<any, any>, (Promise<any> | undefined)[]>
    /**
	 * Registers a Live2DRuntime.
	 */
    static registerRuntime(runtime: Live2DRuntime): void
    /**
	 * Finds a runtime that matches given source.
	 * @param source - Either a settings JSON object or a ModelSettings instance.
	 * @return The Live2DRuntime, or undefined if not found.
	 */
    static findRuntime(source: any): Live2DRuntime | undefined
    /**
	 * Sets up a Live2DModel, populating it with all defined resources.
	 * @param live2dModel - The Live2DModel instance.
	 * @param source - Can be one of: settings file URL, settings JSON object, ModelSettings instance.
	 * @param options - Options for the process.
	 * @return Promise that resolves when all resources have been loaded, rejects when error occurs.
	 */
    static setupLive2DModel<IM extends InternalModel>(live2dModel: Live2DModel<IM>, source: string | object | IM['settings'], options?: Live2DFactoryOptions): Promise<void>
    /**
	 * Loads a Motion and registers the task to {@link motionTasksMap}. The task will be automatically
	 * canceled when its owner - the MotionManager instance - has been destroyed.
	 * @param motionManager - MotionManager that owns this Motion.
	 * @param group - The motion group.
	 * @param index - Index in the motion group.
	 * @return Promise that resolves with the Motion, or with undefined if it can't be loaded.
	 */
    static loadMotion<Motion, MotionSpec>(motionManager: MotionManager<Motion, MotionSpec>, group: string, index: number): Promise<Motion | undefined>
    /**
	 * Loads an Expression and registers the task to {@link expressionTasksMap}. The task will be automatically
	 * canceled when its owner - the ExpressionManager instance - has been destroyed.
	 * @param expressionManager - ExpressionManager that owns this Expression.
	 * @param index - Index of the Expression.
	 * @return Promise that resolves with the Expression, or with undefined if it can't be loaded.
	 */
    static loadExpression<Expression, ExpressionSpec>(expressionManager: ExpressionManager<Expression, ExpressionSpec>, index: number): Promise<Expression | undefined>
    static releaseTasks(this: MotionManager | ExpressionManager): void
}
export interface AutomatorOptions {
    /**
	 * Should the internal model be automatically updated by `PIXI.Ticker.shared`.
	 * @default ture
	 */
    autoUpdate?: boolean
    /**
	 * Should the internal model automatically reacts to interactions by listening for pointer events.
	 * @default true
	 * @deprecated since v0.5.0, reading/writing this property is equivalent to reading/writing `autoHitTest && autoFocus`.
	 */
    autoInteract?: boolean
    /**
	 * Automatically hit-test the model when `pointertap` event is triggered.
	 * @default true
	 */
    autoHitTest?: boolean
    /**
	 * Automatically update the focus position when `globalpointermove` event is triggered.
	 * @default true
	 */
    autoFocus?: boolean
    /**
	 * The ticker to be used for automatic updates.
	 * @default `PIXI.Ticker.shared` from the global PIXI namespace.
	 */
    ticker?: Ticker
}
declare class Automator {
    private static defaultTicker?
    model: Live2DModel
    private destroyed
    private _ticker?
    get ticker(): Ticker | undefined
    set ticker(ticker: Ticker | undefined)
    private _autoUpdate
    /**
	 * @see {@link AutomatorOptions.autoUpdate}
	 */
    get autoUpdate(): boolean
    set autoUpdate(autoUpdate: boolean)
    private _autoHitTest
    /**
	 * @see {@link AutomatorOptions.autoHitTest}
	 */
    get autoHitTest(): boolean
    set autoHitTest(autoHitTest: boolean)
    private _autoFocus
    /**
	 * @see {@link AutomatorOptions.autoFocus}
	 */
    get autoFocus(): boolean
    set autoFocus(autoFocus: boolean)
    /**
	 * @see {@link AutomatorOptions.autoInteract}
	 */
    get autoInteract(): boolean
    set autoInteract(autoInteract: boolean)
    constructor(model: Live2DModel, { autoUpdate, autoHitTest, autoFocus, autoInteract, ticker }?: AutomatorOptions)
    onTickerUpdate(): void
    onTap(event: FederatedPointerEvent): void
    onPointerMove(event: FederatedPointerEvent): void
    destroy(): void
}
/**
 * Useless class. May be useful in the future.
 */
export declare class Live2DTransform extends Transform {
}
export interface Live2DModelOptions extends MotionManagerOptions, AutomatorOptions {
    overWriteBounds?: {
        x0: number,
        y0: number,
        x1: number,
        y1: number
    }
}
export type Live2DConstructor = {
    new (options?: Live2DModelOptions): Live2DModel
}
export declare class Live2DModel<IM extends InternalModel = InternalModel> extends Container {
    static from<M extends Live2DConstructor = typeof Live2DModel>(this: M, source: string | JSONObject | ModelSettings, options?: Live2DFactoryOptions): Promise<InstanceType<M>>
    static fromSync<M extends Live2DConstructor = typeof Live2DModel>(this: M, source: string | JSONObject | ModelSettings, options?: Live2DFactoryOptions): InstanceType<M>
    static registerTicker(tickerClass: typeof Ticker): void
    tag: string
    internalModel: IM
    textures: Texture[]
    transform: Live2DTransform
    anchor: ObservablePoint<any>
    protected glContextID: number
    elapsedTime: DOMHighResTimeStamp
    deltaTime: DOMHighResTimeStamp
    automator: Automator
    overrideBounds: {
        x0: number,
        y0: number,
        x1: number,
        y1: number
    }
    private _alphaFilter
    private _lastWorldAlpha
    constructor(options?: Live2DModelOptions)
    protected init(options?: Live2DModelOptions): void
    protected onAnchorChange(): void
    motion(group: string, index?: number, priority?: MotionPriority, options?: {
        sound?: string,
        volume?: number,
        expression?: number | string,
        resetExpression?: boolean,
        crossOrigin?: string,
        onFinish?: () => void,
        onError?: (e: Error) => void
    }): Promise<boolean>
    stopMotions(): void
    speak(sound: string, options?: {
        volume?: number,
        expression?: number | string,
        resetExpression?: boolean,
        crossOrigin?: string,
        onFinish?: () => void,
        onError?: (e: Error) => void
    }): Promise<boolean>
    stopSpeaking(): void
    expression(id?: number | string): Promise<boolean>
    focus(x: number, y: number, instant?: boolean): void
    tap(x: number, y: number): void
    hitTest(x: number, y: number): string[]
    toModelPosition(position: Point, result?: Point, skipUpdate?: boolean): Point
    containsPoint(point: Point): boolean
    protected _calculateBounds(): void
    update(dt: DOMHighResTimeStamp): void
    _render(renderer: Renderer): void
    destroy(options?: {
        children?: boolean,
        texture?: boolean,
        baseTexture?: boolean
    }): void
}
export declare namespace CubismConfig {
    /**
	 * Support 4x4 mask division, which is unofficial and experimental.
	 * @see https://docs.live2d.com/cubism-sdk-manual/ow-sdk-mask-premake-web/?locale=en_us
	 * @default true
	 */
    const supportMoreMaskDivisions = true
    /**
	 * Set opacity values directly from motion curves, instead of getting the values calculated by Pose.
	 * This can prevent opacity values from being ignored when the model does not have a Pose.
	 * @see https://github.com/guansss/CubismWebFramework/pull/1
	 * @default false
	 */
    const setOpacityFromMotion = false
}
/**
 * Global configs.
 */
export declare const config: {
    LOG_LEVEL_VERBOSE: number,
    LOG_LEVEL_WARNING: number,
    LOG_LEVEL_ERROR: number,
    LOG_LEVEL_NONE: number,
    /**
	 * Global log level.
	 * @default config.LOG_LEVEL_WARNING
	 */
    logLevel: number,
    /**
	 * Enabling sound for motions.
	 */
    sound: boolean,
    /**
	 * Deferring motion and corresponding sound until both are loaded.
	 */
    motionSync: boolean,
    /**
	 * Default fading duration for motions without such value specified.
	 */
    motionFadingDuration: number,
    /**
	 * Default fading duration for idle motions without such value specified.
	 */
    idleMotionFadingDuration: number,
    /**
	 * Default fading duration for expressions without such value specified.
	 */
    expressionFadingDuration: number,
    /**
	 * If false, expression will be reset to default when playing non-idle motions.
	 */
    preserveExpressionOnMotion: boolean
}
export declare const cubism4: typeof CubismConfig
export declare const legacyExpressionBlendMode = false
/**
 * Consistent with the `version` in package.json.
 */
export declare const VERSION: string
export type Live2DLoaderTarget = Live2DModel | InternalModel | MotionManager | ExpressionManager
/**
 * The context transferred through Live2DLoader middlewares.
 */
export interface Live2DLoaderContext {
    /** The XHR's response type. */
    type: XMLHttpRequestResponseType
    /** Will be resolved by {@link ModelSettings.resolveURL} if a ModelSettings is provided. */
    url: string
    /** If provided, the given URL will be resolved by {@link ModelSettings.resolveURL}. */
    settings?: ModelSettings
    /**
	 * Owner of this resource. The load task will be automatically canceled
	 * when receiving an "destroy" event from the target.
	 */
    target?: Live2DLoaderTarget
    /** Loaded data. */
    result?: any
}
export declare class Live2DLoader {
    static middlewares: Middleware<Live2DLoaderContext>[]
    /**
	 * Loads a resource.
	 * @return Promise that resolves with the loaded data in a format that's consistent with the specified `type`.
	 */
    static load<T = any>(context: Live2DLoaderContext): Promise<T>
}
/**
 * The basic XHR loader.
 *
 * A network error will be thrown with the following properties:
 * - `url` - The request URL.
 * - `status` - The HTTP status.
 * - `aborted` - True if the error is caused by aborting the XHR.
 */
export declare class XHRLoader {
    /**
	 * All the created XHRs, keyed by their owners respectively.
	 */
    static xhrMap: WeakMap<Live2DLoaderTarget, Set<XMLHttpRequest>>
    /**
	 * All the created XHRs as a flat array.
	 */
    static allXhrSet: Set<XMLHttpRequest>
    /**
	 * Middleware for Live2DLoader.
	 */
    static loader: Middleware<Live2DLoaderContext>
    /**
	 * Creates a managed XHR.
	 * @param target - If provided, the XHR will be canceled when receiving an "destroy" event from the target.
	 * @param url - The URL.
	 * @param type - The XHR response type.
	 * @param onload - Load listener.
	 * @param onerror - Error handler.
	 */
    static createXHR<T = any>(target: Live2DLoaderTarget | undefined, url: string, type: XMLHttpRequestResponseType, onload: (data: T) => void, onerror: (e: Error) => void): XMLHttpRequest
    /**
	 * Cancels all XHRs related to this target.
	 */
    static cancelXHRs(this: Live2DLoaderTarget): void
    /**
	 * Release all XHRs.
	 */
    static release(): void
}
export type ExtendedFileList = File[] & {
    settings?: ModelSettings
}
/**
 * Experimental loader to load resources from uploaded files.
 *
 * This loader relies on
 * [webkitRelativePath](https://developer.mozilla.org/en-US/docs/Web/API/File/webkitRelativePath)
 * to recognize the file path.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
export declare class FileLoader {
    private static live2dFactory
    /**
	 * Stores all the object URLs of uploaded files.
	 */
    static filesMap: {
        [settingsFileURL: string]: {
            [resourceFileURL: string]: string
        }
    }
    /**
	 * Resolves the path of a resource file to the object URL.
	 * @param settingsURL - Object URL of the settings file.
	 * @param filePath - Resource file path.
	 * @return Resolved object URL.
	 */
    static resolveURL(settingsURL: string, filePath: string): string
    /**
	 * Middleware for Live2DFactory.
	 */
    static factory: Middleware<Live2DFactoryContext>
    /**
	 * Consumes the files by storing their object URLs. Files not defined in the settings will be ignored.
	 */
    static upload(files: File[], settings: ModelSettings): Promise<void>
    /**
	 * Creates a ModelSettings by given files.
	 * @return Promise that resolves with the created ModelSettings.
	 */
    static createSettings(files: File[]): Promise<ModelSettings>
    /**
	 * Reads a file as text in UTF-8.
	 */
    static readText(file: File): Promise<string>
}
export type ZipReader = any
/**
 * Experimental loader to load resources from a zip file.
 *
 * Though named as a "Loader", this class has nothing to do with Live2DLoader,
 * it only contains a middleware for the Live2DFactory.
 */
export declare class ZipLoader {
    private static live2dFactory
    static ZIP_PROTOCOL: string
    static uid: number
    static factory: Middleware<Live2DFactoryContext>
    static unzip(reader: ZipReader, settings: ModelSettings): Promise<File[]>
    static createSettings(reader: ZipReader): Promise<ModelSettings>
    static zipReader(data: Blob, url: string): Promise<ZipReader>
    static getFilePaths(reader: ZipReader): Promise<string[]>
    static getFiles(reader: ZipReader, paths: string[]): Promise<File[]>
    static readText(reader: ZipReader, path: string): Promise<string>
    static releaseReader(reader: ZipReader): void
}
/**
 * A simple tagged logger.
 *
 * You can replace the methods with your own ones.
 *
 * ```js
 * import { logger } from 'pixi-live2d-display';
 *
 * logger.log = (tag, ...messages) => {
 *     console.log(tag, 'says:', ...messages);
 * };
 * ```
 */
export declare const logger: {
    log(tag: string, ...messages: any[]): void,
    warn(tag: string, ...messages: any[]): void,
    error(tag: string, ...messages: any[]): void
}
/**
 * These functions can be slightly faster than the ones in Lodash.
 * @packageDocumentation
 */
export declare function clamp(num: number, lower: number, upper: number): number
export declare function rand(min: number, max: number): number
/**
 * Copies a property at only if it matches the `type`.
 * @param type - Type expected to match `typeof` on the property.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the property in source object.
 * @param toKey - Key of the property in destination object.
 */
export declare function copyProperty<From, FromKey extends keyof From, ToKey extends keyof any, To extends Partial<Record<ToKey, From[FromKey]>>>(type: string, from: From, to: To, fromKey: FromKey, toKey: ToKey): void
/**
 * Copies an array at `key`, filtering the items that match the `type`.
 * @param type - Type expected to match `typeof` on the items.
 * @param from - Source object.
 * @param to - Destination object.
 * @param fromKey - Key of the array property in source object.
 * @param toKey - Key of the array property in destination object.
 */
export declare function copyArray<FromKey extends keyof any, From extends Partial<Record<FromKey, any[]>>, ToKey extends keyof any, To extends Partial<Record<ToKey, any[]>>>(type: string, from: From, to: To, fromKey: FromKey, toKey: ToKey): void
/**
 * @see {@link https://www.typescriptlang.org/docs/handbook/mixins.html}
 */
export declare function applyMixins(derivedCtor: any, baseCtors: any[]): void
/**
 * Gets the name of parent folder in a url.
 * @param url - URL of a file.
 * @return Name of the parent folder, or the file itself if it has no parent folder.
 */
export declare function folderName(url: string): string
/**
 * Remove an element from array.
 */
export declare function remove<T>(array: T[], item: T): void
declare interface Live2DMotion {
    onFinishHandler?(motion: this): void
}
export namespace Cubism2Spec {
    interface ModelJSON {
        name?: string
        // files
        model: string
        pose?: string
        physics?: string
        textures: string[]
        // metadata
        layout?: Layout
        hit_areas?: HitArea[]
        init_params?: InitParam[]
        init_opacities?: InitOpacity[]
        // motions
        expressions?: Expression[]
        motions?: Record<string, Motion[]>
    }
    interface Layout {
        width?: number
        height?: number
        x?: number
        y?: number
        center_x?: number
        center_y?: number
        top?: number
        bottom?: number
        left?: number
        right?: number
    }
    interface Motion {
        /** `*.mtn` file. */
        file: string
        /** Sound file. */
        sound?: string
        /** Motion fade-in timeout. */
        fade_in?: number
        /** Motion fade-out timeout. */
        fade_out?: number
    }
    interface Expression {
        name: string
        /** `*.json` file. */
        file: string
    }
    interface HitArea {
        name: string
        id: string
    }
    interface InitParam {
        id: string
        value: number
    }
    interface InitOpacity {
        id: string
        value: number
    }
    interface ExpressionJSON {
        fade_in?: number
        fade_out?: number
        params?: {
            id: string,
            val: number,
            def?: number,
            calc?: 'set' | 'add' | 'mult'
        }[]
    }
    interface PhysicsJSON {
        physics_hair?: {
            comment: string,
            setup: {
                length: number,
                regist: number,
                mass: number
            },
            src: {
                id: string,
                ptype: 'x' | 'y' | 'angle',
                scale: number,
                weight: number
            }[],
            targets: {
                id: string,
                ptype: 'x' | 'y' | 'angle',
                scale: number,
                weight: number
            }[]
        }[]
    }
    interface PoseJSON {
        parts_visible: {
            group: {
                id: string,
                link?: string[]
            }[]
        }[]
    }
}
export declare class Cubism2ModelSettings extends ModelSettings {
    json: Cubism2Spec.ModelJSON
    moc: string
    textures: string[]
    pose?: string
    physics?: string
    layout?: Cubism2Spec.Layout
    hitAreas?: Cubism2Spec.HitArea[]
    initParams?: Cubism2Spec.InitParam[]
    initOpacities?: Cubism2Spec.InitOpacity[]
    expressions?: Cubism2Spec.Expression[]
    motions: Record<string, Cubism2Spec.Motion[]>
    /**
	 * Checks if a JSON object is valid model settings.
	 * @param json
	 */
    static isValidJSON(json: any): json is Cubism2Spec.ModelJSON
    constructor(json: Cubism2Spec.ModelJSON & {
        url: string
    })
    /**
	 * Validates and copies *optional* properties from raw JSON.
	 */
    protected copy(json: Cubism2Spec.ModelJSON): void
    replaceFiles(replace: (file: string, path: string) => string): void
}
export declare class Live2DExpression extends AMotion {
    readonly params: NonNullable<Cubism2Spec.ExpressionJSON['params']>
    constructor(json: Cubism2Spec.ExpressionJSON)
    /** @override */
    updateParamExe(model: Live2DModelWebGL, time: number, weight: number, motionQueueEnt: unknown): void
}
export declare class Cubism2ExpressionManager extends ExpressionManager<Live2DExpression> {
    readonly queueManager: MotionQueueManager
    readonly definitions: Cubism2Spec.Expression[]
    readonly settings: Cubism2ModelSettings
    constructor(settings: Cubism2ModelSettings, options?: MotionManagerOptions)
    isFinished(): boolean
    getExpressionIndex(name: string): number
    getExpressionFile(definition: Cubism2Spec.Expression): string
    createExpression(data: object, definition: Cubism2Spec.Expression | undefined): Live2DExpression
    protected _setExpression(motion: Live2DExpression): number
    protected stopAllExpressions(): void
    protected updateParameters(model: Live2DModelWebGL, dt: number): boolean
}
export declare class Cubism2MotionManager extends MotionManager<Live2DMotion, Cubism2Spec.Motion> {
    readonly definitions: Partial<Record<string, Cubism2Spec.Motion[]>>
    readonly groups: {
        readonly idle: 'idle'
    }
    readonly motionDataType = 'arraybuffer'
    readonly queueManager: MotionQueueManager
    readonly lipSyncIds: string[]
    readonly settings: Cubism2ModelSettings
    expressionManager?: Cubism2ExpressionManager
    constructor(settings: Cubism2ModelSettings, options?: MotionManagerOptions)
    protected init(options?: MotionManagerOptions): void
    isFinished(): boolean
    createMotion(data: ArrayBuffer, group: string, definition: Cubism2Spec.Motion): Live2DMotion
    getMotionFile(definition: Cubism2Spec.Motion): string
    protected getMotionName(definition: Cubism2Spec.Motion): string
    protected getSoundFile(definition: Cubism2Spec.Motion): string | undefined
    protected _startMotion(motion: Live2DMotion, onFinish?: (motion: Live2DMotion) => void): number
    protected _stopAllMotions(): void
    protected updateParameters(model: Live2DModelWebGL, now: DOMHighResTimeStamp): boolean
    destroy(): void
}
export declare const enum EyeState {
    Idle = 0,
    Closing = 1,
    Closed = 2,
    Opening = 3
}
export declare class Live2DEyeBlink {
    readonly coreModel: Live2DModelWebGL
    leftParam: number
    rightParam: number
    blinkInterval: DOMHighResTimeStamp
    blinkIntervalRandom: DOMHighResTimeStamp
    closingDuration: DOMHighResTimeStamp
    closedDuration: DOMHighResTimeStamp
    openingDuration: DOMHighResTimeStamp
    eyeState: EyeState
    eyeParamValue: number
    closedTimer: number
    nextBlinkTimeLeft: number
    constructor(coreModel: Live2DModelWebGL)
    setEyeParams(value: number): void
    /**
	 * 计算新的眨眼间隔，包括随机值
	 */
    recalculateBlinkInterval(): void
    update(dt: DOMHighResTimeStamp): void
}
export declare class Live2DPhysics {
    readonly coreModel: Live2DModelWebGL
    physicsHairs: PhysicsHair[]
    constructor(coreModel: Live2DModelWebGL, json: Cubism2Spec.PhysicsJSON)
    update(elapsed: DOMHighResTimeStamp): void
}
declare class Live2DPartsParam {
    readonly id: string
    paramIndex: number
    partsIndex: number
    link: Live2DPartsParam[]
    constructor(id: string)
    initIndex(model: Live2DModelWebGL): void
}
export declare class Live2DPose {
    readonly coreModel: Live2DModelWebGL
    opacityAnimDuration: DOMHighResTimeStamp
    partsGroups: Live2DPartsParam[][]
    constructor(coreModel: Live2DModelWebGL, json: Cubism2Spec.PoseJSON)
    init(): void
    normalizePartsOpacityGroup(partsGroup: Live2DPartsParam[], dt: DOMHighResTimeStamp): void
    copyOpacity(partsGroup: Live2DPartsParam[]): void
    update(dt: DOMHighResTimeStamp): void
}
export declare class Cubism2InternalModel extends InternalModel {
    settings: Cubism2ModelSettings
    coreModel: Live2DModelWebGL
    motionManager: Cubism2MotionManager
    eyeBlink?: Live2DEyeBlink
    physics?: Live2DPhysics
    pose?: Live2DPose
    eyeballXParamIndex: number
    eyeballYParamIndex: number
    angleXParamIndex: number
    angleYParamIndex: number
    angleZParamIndex: number
    bodyAngleXParamIndex: number
    breathParamIndex: number
    textureFlipY: boolean
    lipSync: boolean
    /**
	 * Number of the drawables in this model.
	 */
    drawDataCount: number
    /**
	 * If true, the face culling will always be disabled when drawing the model,
	 * regardless of the model's internal flags.
	 */
    disableCulling: boolean
    private hasDrawn
    constructor(coreModel: Live2DModelWebGL, settings: Cubism2ModelSettings, options?: InternalModelOptions)
    protected init(): void
    protected getSize(): [
        number,
        number
    ]
    protected getLayout(): CommonLayout
    updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void
    bindTexture(index: number, texture: WebGLTexture): void
    protected getHitAreaDefs(): CommonHitArea[]
    getDrawableIDs(): string[]
    getDrawableIndex(id: string): number
    getDrawableVertices(drawIndex: number | string): Float32Array
    hitTest(x: number, y: number): string[]
    update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void
    updateFocus(): void
    updateNaturalMovements(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void
    draw(gl: WebGLRenderingContext): void
    destroy(): void
    setBlinkParam(blinkParam: Partial<BlinkParam>): void
}
export namespace CubismSpec {
    export interface ModelJSON {
        /**
		 * Json file format version.
		 */
        Version: number
        /**
		 * Relative paths from the model3.json to other files.
		 */
        FileReferences: {
            /**
			 * Relative path to the moc3 file.
			 */
            Moc: string,
            /**
			 * Relative paths to the textures.
			 */
            Textures: string[],
            /**
			 * [Optional] Relative path to the physics3.json file.
			 */
            Physics?: string,
            /**
			 * [Optional] Relative path to the userdata3.json file.
			 */
            UserData?: string,
            /**
			 * [Optional] Relative path to the pose3.json file.
			 */
            Pose?: string,
            /**
			 * [Optional] Relative path to the cdi3.json file.
			 */
            DisplayInfo?: string,
            /**
			 * [Optional] Relative path to the exp3.json file.
			 */
            Expressions?: Expression[],
            /**
			 * [Optional] Relative path to the motion3.json file.
			 */
            Motions?: {
                /**
				 * This interface was referenced by `undefined`'s JSON-Schema definition
				 * via the `patternProperty` ".+".
				 */
                [k: string]: Motion[]
            }
        }
        /**
		 * [Optional] groups.
		 */
        Groups?: Group[]
        /**
		 * [Optional]Collision detection
		 */
        HitAreas?: HitArea[]
        /**
		 * [Optional]Layout
		 */
        Layout?: {
            Width?: number,
            Height?: number,
            X?: number,
            Y?: number,
            CenterX?: number,
            CenterY?: number
        }
    }
    /**
	 * Motion.
	 */
    export interface Motion {
        /**
		 * File name.
		 */
        File: string
        /**
		 * [Optional] Time of the Fade-out for motion easing in seconds.
		 */
        FadeOutTime?: number
        /**
		 * [Optional] Time of the Fade-In for motion easing in seconds..
		 */
        FadeInTime?: number
        /**
		 * [Optional] Audio files playback with motion.
		 */
        Sound?: string
    }
    /**
	 * Group entry.
	 */
    export interface Group {
        /**
		 * Target of group.
		 */
        Target: string
        /**
		 * Unique name of group.
		 */
        Name: string
        /**
		 * IDs for mapping to target.
		 */
        Ids: string[]
    }
    /**
	 * Collision detection.
	 */
    export interface HitArea {
        /**
		 * Unique name of group.
		 */
        Name: string
        /**
		 * IDs for mapping to target.
		 */
        Id: string
    }
    export interface Expression {
        Name: string
        File: string
    }
    export interface MotionJSON {
        /**
		 * Json file format version.
		 */
        Version: number
        /**
		 * Additional data describing the motion.
		 */
        Meta: {
            /**
			 * Duration of the motion in seconds.
			 */
            Duration: number,
            /**
			 * Framerate of the motion in seconds.
			 */
            Fps: number,
            /**
			 * [Optional] Status of the looping of the motion.
			 */
            Loop?: boolean,
            /**
			 * [Optional] Status of the restriction of Bezier handles'X translations.
			 */
            AreBeziersRestricted?: boolean,
            /**
			 * [Optional] Time of the overall Fade-In for easing in seconds.
			 */
            FadeInTime?: number,
            /**
			 * [Optional] Time of the overall Fade-Out for easing in seconds.
			 */
            FadeOutTime?: number,
            /**
			 * The total number of curves.
			 */
            CurveCount: number,
            /**
			 * The total number of segments (from all curves).
			 */
            TotalSegmentCount: number,
            /**
			 * The total number of points (from all segments of all curves).
			 */
            TotalPointCount: number,
            /**
			 * [Optional] The total number of UserData.
			 */
            UserDataCount?: number,
            /**
			 * [Optional] The total size of UserData in bytes.
			 */
            TotalUserDataSize?: number
        }
        /**
		 * Motion curves.
		 */
        Curves: Curve[]
        /**
		 * [Optional] User data.
		 */
        UserData?: {
            /**
			 * Time in seconds.
			 */
            Time: number,
            /**
			 * Content of user data.
			 */
            Value: string
        }[]
    }
    /**
	 * Single curve.
	 */
    export interface Curve {
        /**
		 * Target type.
		 */
        Target: string
        /**
		 * Identifier for mapping curve to target.
		 */
        Id: string
        /**
		 * [Optional] Time of the Fade-In for easing in seconds.
		 */
        FadeInTime?: number
        /**
		 * [Optional] Time of the Fade-Out for easing in seconds.
		 */
        FadeOutTime?: number
        /**
		 * Flattened segments.
		 */
        Segments: number[]
    }
    export interface ExpressionJSON {
        /**
		 * Json file format type.
		 */
        Type: 'Live2D Expression'
        /**
		 * [Optional] Time of the Fade-In for easing in seconds.
		 */
        FadeInTime?: number
        /**
		 * [Optional] Time of the Fade-Out for easing in seconds.
		 */
        FadeOutTime?: number
        Parameters: {
            Id: string,
            Value: number,
            Blend?: 'Add' | 'Multiply' | 'Overwrite'
        }[]
    }
    export interface PhysicsJSON {
        /**
		 * Physics Settings.
		 */
        PhysicsSettings: {
            /**
			 * Identifier for Physics settings(each model is different).
			 */
            Id: string,
            /**
			 * Input.
			 */
            Input: {
                /**
				 * Targeted parameter.
				 */
                Source: {
                    /**
					 * Target type.
					 */
                    Target: string,
                    /**
					 * Parameter ID.
					 */
                    Id: string
                },
                /**
				 * Effectiveness:propotion of each type（0～100%）.
				 */
                Weight: number,
                /**
				 * Type X or Angle.
				 */
                Type: string,
                /**
				 * Reflect.
				 */
                Reflect: boolean
            }[],
            /**
			 * Output.
			 */
            Output: {
                /**
				 * Targeted parameter.
				 */
                Destination: {
                    /**
					 * Target type.
					 */
                    Target: string,
                    /**
					 * Parameter ID.
					 */
                    Id: string
                },
                /**
				 * Number（0 origin） of parent pendulum（Vertex）.
				 */
                VertexIndex: number,
                /**
				 * Scale
				 */
                Scale: number,
                /**
				 * Effectiveness:propotion of each type（0～100%）.
				 */
                Weight: number,
                /**
				 * Type X or Angle (Angle might be fixed)
				 */
                Type: string,
                /**
				 * Reflect
				 */
                Reflect: boolean
            }[],
            /**
			 * Array of the pendulums
			 */
            Vertices: Vertex[],
            /**
			 * Parameter(input value normalized).
			 */
            Normalization: {
                /**
				 * Normalization value of position.
				 */
                Position: {
                    /**
					 * Normalized minimum.
					 */
                    Minimum: number,
                    /**
					 * Center of the range of normalization.
					 */
                    Default: number,
                    /**
					 * Normalized maximum.
					 */
                    Maximum: number
                },
                /**
				 * Normalization value of angle.
				 */
                Angle: {
                    /**
					 * Normalized minimum.
					 */
                    Minimum: number,
                    /**
					 * Center of the range of normalization.
					 */
                    Default: number,
                    /**
					 * Normalized maximum.
					 */
                    Maximum: number
                }
            }
        }[]
        /**
		 * Json file format version.
		 */
        Version: number
        /**
		 * Additional data describing the physics.
		 */
        Meta: {
            /**
			 * Number of physics settings.
			 */
            PhysicsSettingCount: number,
            /**
			 * Total number of input parameters.
			 */
            TotalInputCount: number,
            /**
			 * Total number of output parameters.
			 */
            TotalOutputCount: number,
            /**
			 * Total number of vertices.
			 */
            VertexCount: number,
            /**
			 * FPS.
			 */
            Fps: number,
            /**
			 * Settings of gravity and wind.
			 */
            EffectiveForces: {
                /**
				 * Gravity.
				 */
                Gravity: {
                    X: number,
                    Y: number
                },
                /**
				 * Wind.
				 */
                Wind: {
                    X: number,
                    Y: number
                }
            },
            /**
			 * List of names and identifiers of Physics setting.
			 */
            PhysicsDictionary: {
                /**
				 * Identifier for Physics settings(each model is different).
				 */
                Id: string,
                /**
				 * Name of Physics settings(group name).
				 */
                Name: string
            }[]
        }
    }
    /**
	 * Single vertex.
	 */
    export interface Vertex {
        /**
		 * Default position.
		 */
        Position: {
            X: number,
            Y: number
        }
        /**
		 * Shaking influence.
		 */
        Mobility: number
        /**
		 * Reaction time.
		 */
        Delay: number
        /**
		 * Overall acceleration.
		 */
        Acceleration: number
        /**
		 * Radius of pendulum.
		 */
        Radius: number
    }
    export interface PoseJSON {
        Type: 'Live2D Pose'
        /**
		 * Time of the Fade-In for easing in seconds.
		 */
        FadeInTime?: number
        /**
		 * List of the switching control groups.
		 */
        Groups: {
            /**
			 * Main switching Part ID.
			 */
            Id: string,
            /**
			 * List of the linked switching Part IDs.
			 */
            Link?: string[]
        }[][]
    }
    export interface UserDataJSON {
        /**
		 * Json file format version.
		 */
        Version: number
        /**
		 * Additional data describing the user data.
		 */
        Meta: {
            /**
			 * The total number of UserData.
			 */
            UserDataCount: number,
            /**
			 * The total size of UserData in bytes.
			 */
            TotalUserDataSize: number
        }
        /**
		 * User data.
		 */
        UserData: UserData[]
    }
    /**
	 * User data.
	 */
    export interface UserData {
        /**
		 * Target type.
		 */
        Target: string
        /**
		 * Identifier for mapping to target.
		 */
        Id: string
        /**
		 * Content of user data.
		 */
        Value: string
    }
}
declare class CubismModelSettingsJson {
    constructor(json: CubismSpec.ModelJSON)
    getEyeBlinkParameters(): string[] | undefined
    getLipSyncParameters(): string[] | undefined
    groups?: CubismSpec.Group[]
    moc: string
    expressions?: CubismSpec.Expression[]
    motions?: Record<string, CubismSpec.Motion[]>
    textures: string[]
    physics?: string
    pose?: string
    hitAreas?: CubismSpec.HitArea[]
    layout?: CubismSpec.ModelJSON['Layout']
}
export interface Cubism4ModelSettings extends CubismModelSettingsJson {
}
export declare class Cubism4ModelSettings extends ModelSettings {
    json: CubismSpec.ModelJSON
    moc: string
    textures: string[]
    static isValidJSON(json: any): json is CubismSpec.ModelJSON
    constructor(json: CubismSpec.ModelJSON & {
        url: string
    })
    replaceFiles(replace: (file: string, path: string) => string): void
}
declare class CubismMatrix44 {
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * 受け取った２つの行列の乗算を行う。
	 *
	 * @param a 行列a
	 * @param b 行列b
	 * @return 乗算結果の行列
	 */
    static multiply(a: Float32Array, b: Float32Array, dst: Float32Array): void
    /**
	 * 単位行列に初期化する
	 */
    loadIdentity(): void
    /**
	 * 行列を設定
	 *
	 * @param tr 16個の浮動小数点数で表される4x4の行列
	 */
    setMatrix(tr: Float32Array): void
    /**
	 * 行列を浮動小数点数の配列で取得
	 *
	 * @return 16個の浮動小数点数で表される4x4の行列
	 */
    getArray(): Float32Array
    /**
	 * X軸の拡大率を取得
	 * @return X軸の拡大率
	 */
    getScaleX(): number
    /**
	 * Y軸の拡大率を取得する
	 *
	 * @return Y軸の拡大率
	 */
    getScaleY(): number
    /**
	 * X軸の移動量を取得
	 * @return X軸の移動量
	 */
    getTranslateX(): number
    /**
	 * Y軸の移動量を取得
	 * @return Y軸の移動量
	 */
    getTranslateY(): number
    /**
	 * X軸の値を現在の行列で計算
	 *
	 * @param src X軸の値
	 * @return 現在の行列で計算されたX軸の値
	 */
    transformX(src: number): number
    /**
	 * Y軸の値を現在の行列で計算
	 *
	 * @param src Y軸の値
	 * @return 現在の行列で計算されたY軸の値
	 */
    transformY(src: number): number
    /**
	 * X軸の値を現在の行列で逆計算
	 */
    invertTransformX(src: number): number
    /**
	 * Y軸の値を現在の行列で逆計算
	 */
    invertTransformY(src: number): number
    /**
	 * 現在の行列の位置を起点にして移動
	 *
	 * 現在の行列の位置を起点にして相対的に移動する。
	 *
	 * @param x X軸の移動量
	 * @param y Y軸の移動量
	 */
    translateRelative(x: number, y: number): void
    /**
	 * 現在の行列の位置を移動
	 *
	 * 現在の行列の位置を指定した位置へ移動する
	 *
	 * @param x X軸の移動量
	 * @param y y軸の移動量
	 */
    translate(x: number, y: number): void
    /**
	 * 現在の行列のX軸の位置を指定した位置へ移動する
	 *
	 * @param x X軸の移動量
	 */
    translateX(x: number): void
    /**
	 * 現在の行列のY軸の位置を指定した位置へ移動する
	 *
	 * @param y Y軸の移動量
	 */
    translateY(y: number): void
    /**
	 * 現在の行列の拡大率を相対的に設定する
	 *
	 * @param x X軸の拡大率
	 * @param y Y軸の拡大率
	 */
    scaleRelative(x: number, y: number): void
    /**
	 * 現在の行列の拡大率を指定した倍率に設定する
	 *
	 * @param x X軸の拡大率
	 * @param y Y軸の拡大率
	 */
    scale(x: number, y: number): void
    /**
	 * 現在の行列に行列を乗算
	 *
	 * @param m 行列
	 */
    multiplyByMatrix(m: CubismMatrix44): void
    /**
	 * オブジェクトのコピーを生成する
	 */
    clone(): CubismMatrix44
    protected _tr: Float32Array
}
declare abstract class CubismRenderer {
    /**
	 * レンダラの初期化処理を実行する
	 * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
	 * @param model モデルのインスタンス
	 */
    initialize(model: CubismModel): void
    /**
	 * モデルを描画する
	 */
    drawModel(): void
    /**
	 * Model-View-Projection 行列をセットする
	 * 配列は複製されるので、元の配列は外で破棄して良い
	 * @param matrix44 Model-View-Projection 行列
	 */
    setMvpMatrix(matrix44: CubismMatrix44): void
    /**
	 * Model-View-Projection 行列を取得する
	 * @return Model-View-Projection 行列
	 */
    getMvpMatrix(): CubismMatrix44
    /**
	 * モデルの色をセットする
	 * 各色0.0~1.0の間で指定する（1.0が標準の状態）
	 * @param red 赤チャンネルの値
	 * @param green 緑チャンネルの値
	 * @param blue 青チャンネルの値
	 * @param alpha αチャンネルの値
	 */
    setModelColor(red: number, green: number, blue: number, alpha: number): void
    /**
	 * モデルの色を取得する
	 * 各色0.0~1.0の間で指定する(1.0が標準の状態)
	 *
	 * @return RGBAのカラー情報
	 */
    getModelColor(): CubismTextureColor
    /**
	 * 乗算済みαの有効・無効をセットする
	 * 有効にするならtrue、無効にするならfalseをセットする
	 */
    setIsPremultipliedAlpha(enable: boolean): void
    /**
	 * 乗算済みαの有効・無効を取得する
	 * @return true 乗算済みのα有効
	 * @return false 乗算済みのα無効
	 */
    isPremultipliedAlpha(): boolean
    /**
	 * カリング（片面描画）の有効・無効をセットする。
	 * 有効にするならtrue、無効にするならfalseをセットする
	 */
    setIsCulling(culling: boolean): void
    /**
	 * カリング（片面描画）の有効・無効を取得する。
	 * @return true カリング有効
	 * @return false カリング無効
	 */
    isCulling(): boolean
    /**
	 * テクスチャの異方性フィルタリングのパラメータをセットする
	 * パラメータ値の影響度はレンダラの実装に依存する
	 * @param n パラメータの値
	 */
    setAnisotropy(n: number): void
    /**
	 * テクスチャの異方性フィルタリングのパラメータをセットする
	 * @return 異方性フィルタリングのパラメータ
	 */
    getAnisotropy(): number
    /**
	 * レンダリングするモデルを取得する
	 * @return レンダリングするモデル
	 */
    getModel(): CubismModel
    /**
	 * マスク描画の方式を変更する。
	 * falseの場合、マスクを1枚のテクスチャに分割してレンダリングする（デフォルト）
	 * 高速だが、マスク個数の上限が36に限定され、質も荒くなる
	 * trueの場合、パーツ描画の前にその都度必要なマスクを描き直す
	 * レンダリング品質は高いが描画処理負荷は増す
	 * @param high 高精細マスクに切り替えるか？
	 */
    useHighPrecisionMask(high: boolean): void
    /**
	 * マスクの描画方式を取得する
	 * @return true 高精細方式
	 * @return false デフォルト
	 */
    isUsingHighPrecisionMask(): boolean
    /**
	 * コンストラクタ
	 */
    protected constructor()
    /**
	 * モデル描画の実装
	 */
    abstract doDrawModel(): void
    /**
	 * 描画オブジェクト（アートメッシュ）を描画する
	 * ポリゴンメッシュとテクスチャ番号をセットで渡す。
	 * @param textureNo 描画するテクスチャ番号
	 * @param indexCount 描画オブジェクトのインデックス値
	 * @param vertexCount ポリゴンメッシュの頂点数
	 * @param indexArray ポリゴンメッシュ頂点のインデックス配列
	 * @param vertexArray ポリゴンメッシュの頂点配列
	 * @param uvArray uv配列
	 * @param opacity 不透明度
	 * @param colorBlendMode カラーブレンディングのタイプ
	 * @param invertedMask マスク使用時のマスクの反転使用
	 */
    abstract drawMesh(textureNo: number, indexCount: number, vertexCount: number, indexArray: Uint16Array, vertexArray: Float32Array, uvArray: Float32Array, multiplyColor: CubismTextureColor, screenColor: CubismTextureColor, opacity: number, colorBlendMode: CubismBlendMode, invertedMask: boolean): void
    /**
	 * モデル描画直前のレンダラのステートを保持する
	 */
    protected abstract saveProfile(): void
    /**
	 * モデル描画直前のレンダラのステートを復帰する
	 */
    protected abstract restoreProfile(): void
    /**
	 * レンダラが保持する静的なリソースを開放する
	 */
    static staticRelease: any
    protected _mvpMatrix4x4: CubismMatrix44
    protected _modelColor: CubismTextureColor
    protected _isCulling: boolean
    protected _isPremultipliedAlpha: boolean
    protected _anisotropy: any
    protected _model: CubismModel
    protected _useHighPrecisionMask: boolean
}
declare enum CubismBlendMode {
    CubismBlendMode_Normal = 0, // 通常
    CubismBlendMode_Additive = 1, // 加算
    CubismBlendMode_Multiplicative = 2
}
declare class CubismTextureColor {
    /**
	 * コンストラクタ
	 */
    constructor(r?: number, g?: number, b?: number, a?: number)
    R: number
    G: number
    B: number
    A: number
}
declare class DrawableColorData {
    constructor(isOverwritten?: boolean, color?: CubismTextureColor)
    isOverwritten: boolean
    Color: CubismTextureColor
}
declare class PartColorData {
    constructor(isOverwritten?: boolean, color?: CubismTextureColor)
    isOverwritten: boolean
    Color: CubismTextureColor
}
declare class CubismModel {
    /**
	 * モデルのパラメータの更新
	 */
    update(): void
    /**
	 * PixelsPerUnitを取得する
	 * @returns PixelsPerUnit
	 */
    getPixelsPerUnit(): number
    /**
	 * キャンバスの幅を取得する
	 */
    getCanvasWidth(): number
    /**
	 * キャンバスの高さを取得する
	 */
    getCanvasHeight(): number
    /**
	 * パラメータを保存する
	 */
    saveParameters(): void
    /**
	 * 乗算色を取得する
	 * @param index Drawablesのインデックス
	 * @returns 指定したdrawableの乗算色(RGBA)
	 */
    getMultiplyColor(index: number): CubismTextureColor
    /**
	 * スクリーン色を取得する
	 * @param index Drawablesのインデックス
	 * @returns 指定したdrawableのスクリーン色(RGBA)
	 */
    getScreenColor(index: number): CubismTextureColor
    /**
	 * 乗算色をセットする
	 * @param index Drawablesのインデックス
	 * @param color 設定する乗算色(CubismTextureColor)
	 */
    setMultiplyColorByTextureColor(index: number, color: CubismTextureColor): void
    /**
	 * 乗算色をセットする
	 * @param index Drawablesのインデックス
	 * @param r 設定する乗算色のR値
	 * @param g 設定する乗算色のG値
	 * @param b 設定する乗算色のB値
	 * @param a 設定する乗算色のA値
	 */
    setMultiplyColorByRGBA(index: number, r: number, g: number, b: number, a?: number): void
    /**
	 * スクリーン色をセットする
	 * @param index Drawablesのインデックス
	 * @param color 設定するスクリーン色(CubismTextureColor)
	 */
    setScreenColorByTextureColor(index: number, color: CubismTextureColor): void
    /**
	 * スクリーン色をセットする
	 * @param index Drawablesのインデックス
	 * @param r 設定するスクリーン色のR値
	 * @param g 設定するスクリーン色のG値
	 * @param b 設定するスクリーン色のB値
	 * @param a 設定するスクリーン色のA値
	 */
    setScreenColorByRGBA(index: number, r: number, g: number, b: number, a?: number): void
    /**
	 * partの乗算色を取得する
	 * @param partIndex partのインデックス
	 * @returns 指定したpartの乗算色
	 */
    getPartMultiplyColor(partIndex: number): CubismTextureColor
    /**
	 * partのスクリーン色を取得する
	 * @param partIndex partのインデックス
	 * @returns 指定したpartのスクリーン色
	 */
    getPartScreenColor(partIndex: number): CubismTextureColor
    /**
	 * partのOverwriteColor setter関数
	 * @param partIndex partのインデックス
	 * @param r 設定する色のR値
	 * @param g 設定する色のG値
	 * @param b 設定する色のB値
	 * @param a 設定する色のA値
	 * @param partColors 設定するpartのカラーデータ配列
	 * @param drawableColors partに関連するDrawableのカラーデータ配列
	 */
    setPartColor(partIndex: number, r: number, g: number, b: number, a: number, partColors: PartColorData[], drawableColors: DrawableColorData[]): void
    /**
	 * 乗算色をセットする
	 * @param partIndex partのインデックス
	 * @param color 設定する乗算色(CubismTextureColor)
	 */
    setPartMultiplyColorByTextureColor(partIndex: number, color: CubismTextureColor): void
    /**
	 * 乗算色をセットする
	 * @param partIndex partのインデックス
	 * @param r 設定する乗算色のR値
	 * @param g 設定する乗算色のG値
	 * @param b 設定する乗算色のB値
	 * @param a 設定する乗算色のA値
	 */
    setPartMultiplyColorByRGBA(partIndex: number, r: number, g: number, b: number, a: number): void
    /**
	 * スクリーン色をセットする
	 * @param partIndex partのインデックス
	 * @param color 設定するスクリーン色(CubismTextureColor)
	 */
    setPartScreenColorByTextureColor(partIndex: number, color: CubismTextureColor): void
    /**
	 * スクリーン色をセットする
	 * @param partIndex partのインデックス
	 * @param r 設定するスクリーン色のR値
	 * @param g 設定するスクリーン色のG値
	 * @param b 設定するスクリーン色のB値
	 * @param a 設定するスクリーン色のA値
	 */
    setPartScreenColorByRGBA(partIndex: number, r: number, g: number, b: number, a: number): void
    /**
	 * SDKから指定したモデルの乗算色を上書きするか
	 * @returns true -> SDKからの情報を優先する
	 *          false -> モデルに設定されている色情報を使用
	 */
    getOverwriteFlagForModelMultiplyColors(): boolean
    /**
	 * SDKから指定したモデルのスクリーン色を上書きするか
	 * @returns true -> SDKからの情報を優先する
	 *          false -> モデルに設定されている色情報を使用
	 */
    getOverwriteFlagForModelScreenColors(): boolean
    /**
	 * SDKから指定したモデルの乗算色を上書きするかセットする
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 */
    setOverwriteFlagForModelMultiplyColors(value: boolean): void
    /**
	 * SDKから指定したモデルのスクリーン色を上書きするかセットする
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 */
    setOverwriteFlagForModelScreenColors(value: boolean): void
    /**
	 * SDKから指定したDrawableIndexの乗算色を上書きするか
	 * @returns true -> SDKからの情報を優先する
	 *          false -> モデルに設定されている色情報を使用
	 */
    getOverwriteFlagForDrawableMultiplyColors(drawableindex: number): boolean
    /**
	 * SDKから指定したDrawableIndexのスクリーン色を上書きするか
	 * @returns true -> SDKからの情報を優先する
	 *          false -> モデルに設定されている色情報を使用
	 */
    getOverwriteFlagForDrawableScreenColors(drawableindex: number): boolean
    /**
	 * SDKから指定したDrawableIndexの乗算色を上書きするかセットする
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 */
    setOverwriteFlagForDrawableMultiplyColors(drawableindex: number, value: boolean): void
    /**
	 * SDKから指定したDrawableIndexのスクリーン色を上書きするかセットする
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 */
    setOverwriteFlagForDrawableScreenColors(drawableindex: number, value: boolean): void
    /**
	 * SDKからpartの乗算色を上書きするか
	 * @param partIndex partのインデックス
	 * @returns true    ->  SDKからの情報を優先する
	 *          false   ->  モデルに設定されている色情報を使用
	 */
    getOverwriteColorForPartMultiplyColors(partIndex: number): boolean
    /**
	 * SDKからpartのスクリーン色を上書きするか
	 * @param partIndex partのインデックス
	 * @returns true    ->  SDKからの情報を優先する
	 *          false   ->  モデルに設定されている色情報を使用
	 */
    getOverwriteColorForPartScreenColors(partIndex: number): boolean
    /**
	 * partのOverwriteFlag setter関数
	 * @param partIndex partのインデックス
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 * @param partColors 設定するpartのカラーデータ配列
	 * @param drawableColors partに関連するDrawableのカラーデータ配列
	 */
    setOverwriteColorForPartColors(partIndex: number, value: boolean, partColors: PartColorData[], drawableColors: DrawableColorData[]): void
    /**
	 * SDKからpartのスクリーン色を上書きするかをセットする
	 * @param partIndex partのインデックス
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 */
    setOverwriteColorForPartMultiplyColors(partIndex: number, value: boolean): void
    /**
	 * SDKからpartのスクリーン色を上書きするかをセットする
	 * @param partIndex partのインデックス
	 * @param value true -> SDKからの情報を優先する
	 *              false -> モデルに設定されている色情報を使用
	 */
    setOverwriteColorForPartScreenColors(partIndex: number, value: boolean): void
    /**
	 * Drawableのカリング情報を取得する。
	 *
	 * @param   drawableIndex   Drawableのインデックス
	 * @return  Drawableのカリング情報
	 */
    getDrawableCulling(drawableIndex: number): boolean
    /**
	 * Drawableのカリング情報を設定する。
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @param isCulling カリング情報
	 */
    setDrawableCulling(drawableIndex: number, isCulling: boolean): void
    /**
	 * SDKからモデル全体のカリング設定を上書きするか。
	 *
	 * @retval  true    ->  SDK上のカリング設定を使用
	 * @retval  false   ->  モデルのカリング設定を使用
	 */
    getOverwriteFlagForModelCullings(): boolean
    /**
	 * SDKからモデル全体のカリング設定を上書きするかを設定する。
	 *
	 * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse
	 */
    setOverwriteFlagForModelCullings(isOverwrittenCullings: boolean): void
    /**
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @retval  true    ->  SDK上のカリング設定を使用
	 * @retval  false   ->  モデルのカリング設定を使用
	 */
    getOverwriteFlagForDrawableCullings(drawableIndex: number): boolean
    /**
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse
	 */
    setOverwriteFlagForDrawableCullings(drawableIndex: number, isOverwrittenCullings: boolean): void
    /**
	 * モデルの不透明度を取得する
	 *
	 * @returns 不透明度の値
	 */
    getModelOapcity(): number
    /**
	 * モデルの不透明度を設定する
	 *
	 * @param value 不透明度の値
	 */
    setModelOapcity(value: number): void
    /**
	 * モデルを取得
	 */
    getModel(): Live2DCubismCore.Model
    /**
	 * パーツのインデックスを取得
	 * @param partId パーツのID
	 * @return パーツのインデックス
	 */
    getPartIndex(partId: string): number
    /**
	 * パーツのIDを取得する。
	 *
	 * @param partIndex 取得するパーツのインデックス
	 * @return パーツのID
	 */
    getPartId(partIndex: number): string
    /**
	 * パーツの個数の取得
	 * @return パーツの個数
	 */
    getPartCount(): number
    /**
	 * パーツの不透明度の設定(Index)
	 * @param partIndex パーツのインデックス
	 * @param opacity 不透明度
	 */
    setPartOpacityByIndex(partIndex: number, opacity: number): void
    /**
	 * パーツの不透明度の設定(Id)
	 * @param partId パーツのID
	 * @param opacity パーツの不透明度
	 */
    setPartOpacityById(partId: string, opacity: number): void
    /**
	 * パーツの不透明度の取得(index)
	 * @param partIndex パーツのインデックス
	 * @return パーツの不透明度
	 */
    getPartOpacityByIndex(partIndex: number): number
    /**
	 * パーツの不透明度の取得(id)
	 * @param partId パーツのＩｄ
	 * @return パーツの不透明度
	 */
    getPartOpacityById(partId: string): number
    /**
	 * パラメータのインデックスの取得
	 * @param パラメータID
	 * @return パラメータのインデックス
	 */
    getParameterIndex(parameterId: string): number
    /**
	 * パラメータの個数の取得
	 * @return パラメータの個数
	 */
    getParameterCount(): number
    /**
	 * パラメータの種類の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return csmParameterType_Normal -> 通常のパラメータ
	 *          csmParameterType_BlendShape -> ブレンドシェイプパラメータ
	 */
    getParameterType(parameterIndex: number): Live2DCubismCore.csmParameterType
    /**
	 * パラメータの最大値の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return パラメータの最大値
	 */
    getParameterMaximumValue(parameterIndex: number): number
    /**
	 * パラメータの最小値の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return パラメータの最小値
	 */
    getParameterMinimumValue(parameterIndex: number): number
    /**
	 * パラメータのデフォルト値の取得
	 * @param parameterIndex パラメータのインデックス
	 * @return パラメータのデフォルト値
	 */
    getParameterDefaultValue(parameterIndex: number): number
    /**
	 * パラメータの値の取得
	 * @param parameterIndex    パラメータのインデックス
	 * @return パラメータの値
	 */
    getParameterValueByIndex(parameterIndex: number): number
    /**
	 * パラメータの値の取得
	 * @param parameterId    パラメータのID
	 * @return パラメータの値
	 */
    getParameterValueById(parameterId: string): number
    /**
	 * パラメータの値の設定
	 * @param parameterIndex パラメータのインデックス
	 * @param value パラメータの値
	 * @param weight 重み
	 */
    setParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void
    /**
	 * パラメータの値の設定
	 * @param parameterId パラメータのID
	 * @param value パラメータの値
	 * @param weight 重み
	 */
    setParameterValueById(parameterId: string, value: number, weight?: number): void
    /**
	 * パラメータの値の加算(index)
	 * @param parameterIndex パラメータインデックス
	 * @param value 加算する値
	 * @param weight 重み
	 */
    addParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void
    /**
	 * パラメータの値の加算(id)
	 * @param parameterId パラメータＩＤ
	 * @param value 加算する値
	 * @param weight 重み
	 */
    addParameterValueById(parameterId: any, value: number, weight?: number): void
    /**
	 * パラメータの値の乗算
	 * @param parameterId パラメータのID
	 * @param value 乗算する値
	 * @param weight 重み
	 */
    multiplyParameterValueById(parameterId: string, value: number, weight?: number): void
    /**
	 * パラメータの値の乗算
	 * @param parameterIndex パラメータのインデックス
	 * @param value 乗算する値
	 * @param weight 重み
	 */
    multiplyParameterValueByIndex(parameterIndex: number, value: number, weight?: number): void
    getDrawableIds(): string[]
    /**
	 * Drawableのインデックスの取得
	 * @param drawableId DrawableのID
	 * @return Drawableのインデックス
	 */
    getDrawableIndex(drawableId: string): number
    /**
	 * Drawableの個数の取得
	 * @return drawableの個数
	 */
    getDrawableCount(): number
    /**
	 * DrawableのIDを取得する
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのID
	 */
    getDrawableId(drawableIndex: number): string
    /**
	 * Drawableの描画順リストの取得
	 * @return Drawableの描画順リスト
	 */
    getDrawableRenderOrders(): Int32Array
    /**
	 * @deprecated
	 * 関数名が誤っていたため、代替となる getDrawableTextureIndex を追加し、この関数は非推奨となりました。
	 *
	 * Drawableのテクスチャインデックスリストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのテクスチャインデックスリスト
	 */
    getDrawableTextureIndices(drawableIndex: number): number
    /**
	 * Drawableのテクスチャインデックスの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのテクスチャインデックス
	 */
    getDrawableTextureIndex(drawableIndex: number): number
    /**
	 * DrawableのVertexPositionsの変化情報の取得
	 *
	 * 直近のCubismModel.update関数でDrawableの頂点情報が変化したかを取得する。
	 *
	 * @param   drawableIndex   Drawableのインデックス
	 * @retval  true    Drawableの頂点情報が直近のCubismModel.update関数で変化した
	 * @retval  false   Drawableの頂点情報が直近のCubismModel.update関数で変化していない
	 */
    getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex: number): boolean
    /**
	 * Drawableの頂点インデックスの個数の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点インデックスの個数
	 */
    getDrawableVertexIndexCount(drawableIndex: number): number
    /**
	 * Drawableの頂点の個数の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点の個数
	 */
    getDrawableVertexCount(drawableIndex: number): number
    /**
	 * Drawableの頂点リストの取得
	 * @param drawableIndex drawableのインデックス
	 * @return drawableの頂点リスト
	 */
    getDrawableVertices(drawableIndex: number): Float32Array
    /**
	 * Drawableの頂点インデックスリストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点インデックスリスト
	 */
    getDrawableVertexIndices(drawableIndex: number): Uint16Array
    /**
	 * Drawableの頂点リストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点リスト
	 */
    getDrawableVertexPositions(drawableIndex: number): Float32Array
    /**
	 * Drawableの頂点のUVリストの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの頂点UVリスト
	 */
    getDrawableVertexUvs(drawableIndex: number): Float32Array
    /**
	 * Drawableの不透明度の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの不透明度
	 */
    getDrawableOpacity(drawableIndex: number): number
    /**
	 * Drawableの乗算色の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの乗算色(RGBA)
	 * スクリーン色はRGBAで取得されるが、Aは必ず0
	 */
    getDrawableMultiplyColor(drawableIndex: number): CubismTextureColor
    /**
	 * Drawableのスクリーン色の取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのスクリーン色(RGBA)
	 * スクリーン色はRGBAで取得されるが、Aは必ず0
	 */
    getDrawableScreenColor(drawableIndex: number): CubismTextureColor
    /**
	 * Drawableの親パーツのインデックスの取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableの親パーツのインデックス
	 */
    getDrawableParentPartIndex(drawableIndex: number): number
    /**
	 * Drawableのブレンドモードを取得
	 * @param drawableIndex Drawableのインデックス
	 * @return drawableのブレンドモード
	 */
    getDrawableBlendMode(drawableIndex: number): CubismBlendMode
    /**
	 * Drawableのマスクの反転使用の取得
	 *
	 * Drawableのマスク使用時の反転設定を取得する。
	 * マスクを使用しない場合は無視される。
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return Drawableの反転設定
	 */
    getDrawableInvertedMaskBit(drawableIndex: number): boolean
    /**
	 * Drawableのクリッピングマスクリストの取得
	 * @return Drawableのクリッピングマスクリスト
	 */
    getDrawableMasks(): Int32Array[]
    /**
	 * Drawableのクリッピングマスクの個数リストの取得
	 * @return Drawableのクリッピングマスクの個数リスト
	 */
    getDrawableMaskCounts(): Int32Array
    /**
	 * クリッピングマスクの使用状態
	 *
	 * @return true クリッピングマスクを使用している
	 * @return false クリッピングマスクを使用していない
	 */
    isUsingMasking(): boolean
    /**
	 * Drawableの表示情報を取得する
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return true Drawableが表示
	 * @return false Drawableが非表示
	 */
    getDrawableDynamicFlagIsVisible(drawableIndex: number): boolean
    /**
	 * DrawableのDrawOrderの変化情報の取得
	 *
	 * 直近のCubismModel.update関数でdrawableのdrawOrderが変化したかを取得する。
	 * drawOrderはartMesh上で指定する0から1000の情報
	 * @param drawableIndex drawableのインデックス
	 * @return true drawableの不透明度が直近のCubismModel.update関数で変化した
	 * @return false drawableの不透明度が直近のCubismModel.update関数で変化している
	 */
    getDrawableDynamicFlagVisibilityDidChange(drawableIndex: number): boolean
    /**
	 * Drawableの不透明度の変化情報の取得
	 *
	 * 直近のCubismModel.update関数でdrawableの不透明度が変化したかを取得する。
	 *
	 * @param drawableIndex drawableのインデックス
	 * @return true Drawableの不透明度が直近のCubismModel.update関数で変化した
	 * @return false Drawableの不透明度が直近のCubismModel.update関数で変化してない
	 */
    getDrawableDynamicFlagOpacityDidChange(drawableIndex: number): boolean
    /**
	 * Drawableの描画順序の変化情報の取得
	 *
	 * 直近のCubismModel.update関数でDrawableの描画の順序が変化したかを取得する。
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return true Drawableの描画の順序が直近のCubismModel.update関数で変化した
	 * @return false Drawableの描画の順序が直近のCubismModel.update関数で変化してない
	 */
    getDrawableDynamicFlagRenderOrderDidChange(drawableIndex: number): boolean
    /**
	 * Drawableの乗算色・スクリーン色の変化情報の取得
	 *
	 * 直近のCubismModel.update関数でDrawableの乗算色・スクリーン色が変化したかを取得する。
	 *
	 * @param drawableIndex Drawableのインデックス
	 * @return true Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化した
	 * @return false Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化してない
	 */
    getDrawableDynamicFlagBlendColorDidChange(drawableIndex: number): boolean
    /**
	 * 保存されたパラメータの読み込み
	 */
    loadParameters(): void
    /**
	 * 初期化する
	 */
    initialize(): void
    /**
	 * コンストラクタ
	 * @param model モデル
	 */
    constructor(model: Live2DCubismCore.Model)
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    private _notExistPartOpacities
    private _notExistPartId
    private _notExistParameterValues
    private _notExistParameterId
    private _savedParameters
    private _isOverwrittenModelMultiplyColors
    private _isOverwrittenModelScreenColors
    private _userMultiplyColors
    private _userScreenColors
    private _userPartScreenColors
    private _userPartMultiplyColors
    private _partChildDrawables
    private _model
    private _parameterValues
    private _parameterMaximumValues
    private _parameterMinimumValues
    private _partOpacities
    private _modelOpacity
    private _parameterIds
    private _partIds
    private _drawableIds
    private _isOverwrittenCullings
    private _userCullings
}
declare class CubismMotionQueueManager {
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ
	 */
    release(): void
    /**
	 * 指定したモーションの開始
	 *
	 * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。
	 *
	 * @param   motion          開始するモーション
	 * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true
	 * @param   userTimeSeconds デルタ時間の積算値[秒]
	 * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」
	 */
    startMotion(motion: ACubismMotion, autoDelete: boolean, userTimeSeconds: number): CubismMotionQueueEntryHandle
    /**
	 * 全てのモーションの終了の確認
	 * @return true 全て終了している
	 * @return false 終了していない
	 */
    isFinished(): boolean
    /**
	 * 指定したモーションの終了の確認
	 * @param motionQueueEntryNumber モーションの識別番号
	 * @return true 全て終了している
	 * @return false 終了していない
	 */
    isFinishedByHandle(motionQueueEntryNumber: CubismMotionQueueEntryHandle): boolean
    /**
	 * 全てのモーションを停止する
	 */
    stopAllMotions(): void
    /**
	 * 指定したCubismMotionQueueEntryの取得

	 * @param   motionQueueEntryNumber  モーションの識別番号
	 * @return  指定したCubismMotionQueueEntry
	 * @return  null   見つからなかった
	 */
    getCubismMotionQueueEntry(motionQueueEntryNumber: any): CubismMotionQueueEntry | undefined
    /**
	 * イベントを受け取るCallbackの登録
	 *
	 * @param callback コールバック関数
	 * @param customData コールバックに返されるデータ
	 */
    setEventCallback(callback: CubismMotionEventFunction, customData?: any): void
    /**
	 * モーションを更新して、モデルにパラメータ値を反映する。
	 *
	 * @param   model   対象のモデル
	 * @param   userTimeSeconds   デルタ時間の積算値[秒]
	 * @return  true    モデルへパラメータ値の反映あり
	 * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)
	 */
    doUpdateMotion(model: CubismModel, userTimeSeconds: number): boolean
    _userTimeSeconds: number
    _motions: CubismMotionQueueEntry[]
    _eventCallBack: CubismMotionEventFunction
    _eventCustomData: any
}
/**
 * イベントのコールバック関数を定義
 *
 * イベントのコールバックに登録できる関数の型情報
 * @param caller        発火したイベントを再生させたCubismMotionQueueManager
 * @param eventValue    発火したイベントの文字列データ
 * @param customData   コールバックに返される登録時に指定されたデータ
 */
export interface CubismMotionEventFunction {
    (caller: CubismMotionQueueManager, eventValue: string, customData: any): void
}
/**
 * モーションの識別番号
 *
 * モーションの識別番号の定義
 */
export declare type CubismMotionQueueEntryHandle = any
declare class CubismMotionQueueEntry {
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * フェードアウト時間と開始判定の設定
	 * @param fadeOutSeconds フェードアウトにかかる時間[秒]
	 */
    setFadeOut(fadeOutSeconds: number): void
    /**
	 * フェードアウトの開始
	 * @param fadeOutSeconds フェードアウトにかかる時間[秒]
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 */
    startFadeOut(fadeOutSeconds: number, userTimeSeconds: number): void
    /**
	 * モーションの終了の確認
	 *
	 * @return true モーションが終了した
	 * @return false 終了していない
	 */
    isFinished(): boolean
    /**
	 * モーションの開始の確認
	 * @return true モーションが開始した
	 * @return false 開始していない
	 */
    isStarted(): boolean
    /**
	 * モーションの開始時刻の取得
	 * @return モーションの開始時刻[秒]
	 */
    getStartTime(): number
    /**
	 * フェードインの開始時刻の取得
	 * @return フェードインの開始時刻[秒]
	 */
    getFadeInStartTime(): number
    /**
	 * フェードインの終了時刻の取得
	 * @return フェードインの終了時刻の取得
	 */
    getEndTime(): number
    /**
	 * モーションの開始時刻の設定
	 * @param startTime モーションの開始時刻
	 */
    setStartTime(startTime: number): void
    /**
	 * フェードインの開始時刻の設定
	 * @param startTime フェードインの開始時刻[秒]
	 */
    setFadeInStartTime(startTime: number): void
    /**
	 * フェードインの終了時刻の設定
	 * @param endTime フェードインの終了時刻[秒]
	 */
    setEndTime(endTime: number): void
    /**
	 * モーションの終了の設定
	 * @param f trueならモーションの終了
	 */
    setIsFinished(f: boolean): void
    /**
	 * モーション開始の設定
	 * @param f trueならモーションの開始
	 */
    setIsStarted(f: boolean): void
    /**
	 * モーションの有効性の確認
	 * @return true モーションは有効
	 * @return false モーションは無効
	 */
    isAvailable(): boolean
    /**
	 * モーションの有効性の設定
	 * @param v trueならモーションは有効
	 */
    setIsAvailable(v: boolean): void
    /**
	 * モーションの状態の設定
	 * @param timeSeconds 現在時刻[秒]
	 * @param weight モーション尾重み
	 */
    setState(timeSeconds: number, weight: number): void
    /**
	 * モーションの現在時刻の取得
	 * @return モーションの現在時刻[秒]
	 */
    getStateTime(): number
    /**
	 * モーションの重みの取得
	 * @return モーションの重み
	 */
    getStateWeight(): number
    /**
	 * 最後にイベントの発火をチェックした時間を取得
	 *
	 * @return 最後にイベントの発火をチェックした時間[秒]
	 */
    getLastCheckEventSeconds(): number
    /**
	 * 最後にイベントをチェックした時間を設定
	 * @param checkSeconds 最後にイベントをチェックした時間[秒]
	 */
    setLastCheckEventSeconds(checkSeconds: number): void
    /**
	 * フェードアウト開始判定の取得
	 * @return フェードアウト開始するかどうか
	 */
    isTriggeredFadeOut(): boolean
    /**
	 * フェードアウト時間の取得
	 * @return フェードアウト時間[秒]
	 */
    getFadeOutSeconds(): number
    _autoDelete: boolean
    _motion: ACubismMotion
    _available: boolean
    _finished: boolean
    _started: boolean
    _startTimeSeconds: number
    _fadeInStartTimeSeconds: number
    _endTimeSeconds: number
    _stateTimeSeconds: number
    _stateWeight: number
    _lastEventCheckSeconds: number
    private _fadeOutSeconds
    private _isTriggeredFadeOut
    _motionQueueEntryHandle: CubismMotionQueueEntryHandle
}
declare abstract class ACubismMotion {
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * モデルのパラメータ
	 * @param model 対象のモデル
	 * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 */
    updateParameters(model: CubismModel, motionQueueEntry: CubismMotionQueueEntry, userTimeSeconds: number): void
    /**
	 * フェードインの時間を設定する
	 * @param fadeInSeconds フェードインにかかる時間[秒]
	 */
    setFadeInTime(fadeInSeconds: number): void
    /**
	 * フェードアウトの時間を設定する
	 * @param fadeOutSeconds フェードアウトにかかる時間[秒]
	 */
    setFadeOutTime(fadeOutSeconds: number): void
    /**
	 * フェードアウトにかかる時間の取得
	 * @return フェードアウトにかかる時間[秒]
	 */
    getFadeOutTime(): number
    /**
	 * フェードインにかかる時間の取得
	 * @return フェードインにかかる時間[秒]
	 */
    getFadeInTime(): number
    /**
	 * モーション適用の重みの設定
	 * @param weight 重み（0.0 - 1.0）
	 */
    setWeight(weight: number): void
    /**
	 * モーション適用の重みの取得
	 * @return 重み（0.0 - 1.0）
	 */
    getWeight(): number
    /**
	 * モーションの長さの取得
	 * @return モーションの長さ[秒]
	 *
	 * @note ループの時は「-1」。
	 *       ループでない場合は、オーバーライドする。
	 *       正の値の時は取得される時間で終了する。
	 *       「-1」の時は外部から停止命令がない限り終わらない処理となる。
	 */
    getDuration(): number
    /**
	 * モーションのループ1回分の長さの取得
	 * @return モーションのループ一回分の長さ[秒]
	 *
	 * @note ループしない場合は、getDuration()と同じ値を返す
	 *       ループ一回分の長さが定義できない場合(プログラム的に動き続けるサブクラスなど)の場合は「-1」を返す
	 */
    getLoopDuration(): number
    /**
	 * モーション再生の開始時刻の設定
	 * @param offsetSeconds モーション再生の開始時刻[秒]
	 */
    setOffsetTime(offsetSeconds: number): void
    /**
	 * モデルのパラメータ更新
	 *
	 * イベント発火のチェック。
	 * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
	 *
	 * @param beforeCheckTimeSeconds 前回のイベントチェック時間[秒]
	 * @param motionTimeSeconds 今回の再生時間[秒]
	 */
    getFiredEvent(beforeCheckTimeSeconds: number, motionTimeSeconds: number): string[]
    /**
	 * モーションを更新して、モデルにパラメータ値を反映する
	 * @param model 対象のモデル
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 * @param weight モーションの重み
	 * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
	 * @return true モデルへパラメータ値の反映あり
	 * @return false モデルへのパラメータ値の反映なし（モーションの変化なし）
	 */
    abstract doUpdateParameters(model: CubismModel, userTimeSeconds: number, weight: number, motionQueueEntry: CubismMotionQueueEntry): void
    /**
	 * モーション再生終了コールバックの登録
	 *
	 * モーション再生終了コールバックを登録する。
	 * isFinishedフラグを設定するタイミングで呼び出される。
	 * 以下の状態の際には呼び出されない:
	 *   1. 再生中のモーションが「ループ」として設定されているとき
	 *   2. コールバックが登録されていない時
	 *
	 * @param onFinishedMotionHandler モーション再生終了コールバック関数
	 */
    setFinishedMotionHandler(onFinishedMotionHandler?: (self: ACubismMotion) => void): void
    /**
	 * モーション再生終了コールバックの取得
	 *
	 * モーション再生終了コールバックを取得する。
	 *
	 * @return 登録されているモーション再生終了コールバック関数
	 */
    getFinishedMotionHandler(): ((self: ACubismMotion) => void) | undefined
    /**
	 * 透明度のカーブが存在するかどうかを確認する
	 *
	 * @returns true  -> キーが存在する
	 *          false -> キーが存在しない
	 */
    isExistModelOpacity(): boolean
    /**
	 * 透明度のカーブのインデックスを返す
	 *
	 * @returns success:透明度のカーブのインデックス
	 */
    getModelOpacityIndex(): number
    /**
	 * 透明度のIdを返す
	 *
	 * @param index モーションカーブのインデックス
	 * @returns success:透明度のId
	 */
    getModelOpacityId(index: number): string | undefined
    /**
	 * 指定時間の透明度の値を返す
	 *
	 * @returns success:モーションの現在時間におけるOpacityの値
	 *
	 * @note  更新後の値を取るにはUpdateParameters() の後に呼び出す。
	 */
    protected getModelOpacityValue(): number
    _fadeInSeconds: number
    _fadeOutSeconds: number
    _weight: number
    _offsetSeconds: number
    _firedEventValues: string[]
    _onFinishedMotion?: (self: ACubismMotion) => void
}
declare class CubismExpressionMotion extends ACubismMotion {
    /**
	 * インスタンスを作成する。
	 * @param json expファイルが読み込まれているバッファ
	 * @param size バッファのサイズ
	 * @return 作成されたインスタンス
	 */
    static create(json: CubismSpec.ExpressionJSON): CubismExpressionMotion
    /**
	 * モデルのパラメータの更新の実行
	 * @param model 対象のモデル
	 * @param userTimeSeconds デルタ時間の積算値[秒]
	 * @param weight モーションの重み
	 * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
	 */
    doUpdateParameters(model: CubismModel, userTimeSeconds: number, weight: number, motionQueueEntry: CubismMotionQueueEntry): void
    protected parse(json: CubismSpec.ExpressionJSON): void
    /**
	 * コンストラクタ
	 */
    protected constructor()
    _parameters: ExpressionParameter[]
}
declare enum ExpressionBlendType {
    ExpressionBlendType_Add = 0, // 加算
    ExpressionBlendType_Multiply = 1, // 乗算
    ExpressionBlendType_Overwrite = 2
}
/**
 * 表情のパラメータ情報
 */
export interface ExpressionParameter {
    parameterId: string
    blendType: ExpressionBlendType
    value: number
}
export declare class Cubism4ExpressionManager extends ExpressionManager<CubismExpressionMotion, CubismSpec.Expression> {
    readonly queueManager: CubismMotionQueueManager
    readonly definitions: CubismSpec.Expression[]
    constructor(settings: Cubism4ModelSettings, options?: MotionManagerOptions)
    isFinished(): boolean
    getExpressionIndex(name: string): number
    getExpressionFile(definition: CubismSpec.Expression): string
    createExpression(data: object, definition: CubismSpec.Expression | undefined): CubismExpressionMotion
    protected _setExpression(motion: CubismExpressionMotion): number
    protected stopAllExpressions(): void
    protected updateParameters(model: CubismModel, now: DOMHighResTimeStamp): boolean
}
declare enum CubismMotionCurveTarget {
    CubismMotionCurveTarget_Model = 0, // モデルに対して
    CubismMotionCurveTarget_Parameter = 1, // パラメータに対して
    CubismMotionCurveTarget_PartOpacity = 2
}
declare class CubismMotionPoint {
    constructor(time?: number, value?: number)
    time: number
    value: number
}
/**
 * モーションカーブのセグメントの評価関数
 *
 * @param   points      モーションカーブの制御点リスト
 * @param   time        評価する時間[秒]
 */
export interface csmMotionSegmentEvaluationFunction {
    (points: CubismMotionPoint[], time: number): number
}
declare class CubismMotionSegment {
    /**
	 * @brief コンストラクタ
	 *
	 * コンストラクタ。
	 */
    constructor()
    evaluate: csmMotionSegmentEvaluationFunction
    basePointIndex: number
    segmentType: number
}
declare class CubismMotionCurve {
    constructor()
    type: CubismMotionCurveTarget
    id: string
    segmentCount: number
    baseSegmentIndex: number
    fadeInTime: number
    fadeOutTime: number
}
declare class CubismMotionEvent {
    fireTime: number
    value: string
}
declare class CubismMotionData {
    constructor()
    duration: number
    loop: boolean
    curveCount: number
    eventCount: number
    fps: number
    curves: CubismMotionCurve[]
    segments: CubismMotionSegment[]
    points: CubismMotionPoint[]
    events: CubismMotionEvent[]
}
declare class CubismMotion extends ACubismMotion {
    /**
	 * インスタンスを作成する
	 *
	 * @param json motion3.jsonが読み込まれているバッファ
	 * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
	 * @return 作成されたインスタンス
	 */
    static create(json: CubismSpec.MotionJSON, onFinishedMotionHandler?: (self: ACubismMotion) => void): CubismMotion
    /**
	 * モデルのパラメータの更新の実行
	 * @param model             対象のモデル
	 * @param userTimeSeconds   現在の時刻[秒]
	 * @param fadeWeight        モーションの重み
	 * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション
	 */
    doUpdateParameters(model: CubismModel, userTimeSeconds: number, fadeWeight: number, motionQueueEntry: CubismMotionQueueEntry): void
    /**
	 * ループ情報の設定
	 * @param loop ループ情報
	 */
    setIsLoop(loop: boolean): void
    /**
	 * ループ情報の取得
	 * @return true ループする
	 * @return false ループしない
	 */
    isLoop(): boolean
    /**
	 * ループ時のフェードイン情報の設定
	 * @param loopFadeIn  ループ時のフェードイン情報
	 */
    setIsLoopFadeIn(loopFadeIn: boolean): void
    /**
	 * ループ時のフェードイン情報の取得
	 *
	 * @return  true    する
	 * @return  false   しない
	 */
    isLoopFadeIn(): boolean
    /**
	 * モーションの長さを取得する。
	 *
	 * @return  モーションの長さ[秒]
	 */
    getDuration(): number
    /**
	 * モーションのループ時の長さを取得する。
	 *
	 * @return  モーションのループ時の長さ[秒]
	 */
    getLoopDuration(): number
    /**
	 * パラメータに対するフェードインの時間を設定する。
	 *
	 * @param parameterId     パラメータID
	 * @param value           フェードインにかかる時間[秒]
	 */
    setParameterFadeInTime(parameterId: string, value: number): void
    /**
	 * パラメータに対するフェードアウトの時間の設定
	 * @param parameterId     パラメータID
	 * @param value           フェードアウトにかかる時間[秒]
	 */
    setParameterFadeOutTime(parameterId: string, value: number): void
    /**
	 * パラメータに対するフェードインの時間の取得
	 * @param    parameterId     パラメータID
	 * @return   フェードインにかかる時間[秒]
	 */
    getParameterFadeInTime(parameterId: string): number
    /**
	 * パラメータに対するフェードアウトの時間を取得
	 *
	 * @param   parameterId     パラメータID
	 * @return   フェードアウトにかかる時間[秒]
	 */
    getParameterFadeOutTime(parameterId: string): number
    /**
	 * 自動エフェクトがかかっているパラメータIDリストの設定
	 * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト
	 * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト
	 */
    setEffectIds(eyeBlinkParameterIds: string[], lipSyncParameterIds: string[]): void
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * motion3.jsonをパースする。
	 *
	 * @param motionJson  motion3.jsonが読み込まれているバッファ
	 */
    parse(motionJson: CubismSpec.MotionJSON): void
    /**
	 * モデルのパラメータ更新
	 *
	 * イベント発火のチェック。
	 * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
	 *
	 * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]
	 * @param motionTimeSeconds        今回の再生時間[秒]
	 */
    getFiredEvent(beforeCheckTimeSeconds: number, motionTimeSeconds: number): string[]
    /**
	 * 透明度のカーブが存在するかどうかを確認する
	 *
	 * @returns true  -> キーが存在する
	 *          false -> キーが存在しない
	 */
    isExistModelOpacity(): boolean
    /**
	 * 透明度のカーブのインデックスを返す
	 *
	 * @returns success:透明度のカーブのインデックス
	 */
    getModelOpacityIndex(): number
    /**
	 * 透明度のIdを返す
	 *
	 * @param index モーションカーブのインデックス
	 * @returns success:透明度のカーブのインデックス
	 */
    getModelOpacityId(index: number): string | undefined
    /**
	 * 現在時間の透明度の値を返す
	 *
	 * @returns success:モーションの当該時間におけるOpacityの値
	 */
    getModelOpacityValue(): number
    _sourceFrameRate: number
    _loopDurationSeconds: number
    _isLoop: boolean
    _isLoopFadeIn: boolean
    _lastWeight: number
    _motionData: CubismMotionData
    _eyeBlinkParameterIds: string[]
    _lipSyncParameterIds: string[]
    _modelCurveIdEyeBlink?: string
    _modelCurveIdLipSync?: string
    _modelCurveIdOpacity?: string
    _modelOpacity: number
}
export declare class Cubism4MotionManager extends MotionManager<CubismMotion, CubismSpec.Motion> {
    readonly definitions: Partial<Record<string, CubismSpec.Motion[]>>
    readonly groups: {
        readonly idle: 'Idle'
    }
    readonly motionDataType = 'json'
    readonly queueManager: CubismMotionQueueManager
    readonly settings: Cubism4ModelSettings
    expressionManager?: Cubism4ExpressionManager
    eyeBlinkIds: string[]
    lipSyncIds: string[]
    constructor(settings: Cubism4ModelSettings, options?: MotionManagerOptions)
    protected init(options?: MotionManagerOptions): void
    isFinished(): boolean
    protected _startMotion(motion: CubismMotion, onFinish?: (motion: CubismMotion) => void): number
    protected _stopAllMotions(): void
    createMotion(data: object, group: string, definition: CubismSpec.Motion): CubismMotion
    getMotionFile(definition: CubismSpec.Motion): string
    protected getMotionName(definition: CubismSpec.Motion): string
    protected getSoundFile(definition: CubismSpec.Motion): string | undefined
    protected updateParameters(model: CubismModel, now: DOMHighResTimeStamp): boolean
    destroy(): void
}
declare class CubismBreath {
    /**
	 * インスタンスの作成
	 */
    static create(): CubismBreath
    /**
	 * 呼吸のパラメータの紐づけ
	 * @param breathParameters 呼吸を紐づけたいパラメータのリスト
	 */
    setParameters(breathParameters: BreathParameterData[]): void
    /**
	 * 呼吸に紐づいているパラメータの取得
	 * @return 呼吸に紐づいているパラメータのリスト
	 */
    getParameters(): BreathParameterData[]
    /**
	 * モデルのパラメータの更新
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
    updateParameters(model: CubismModel, deltaTimeSeconds: number): void
    /**
	 * コンストラクタ
	 */
    constructor()
    _breathParameters: BreathParameterData[]
    _currentTime: number
}
declare class BreathParameterData {
    /**
	 * コンストラクタ
	 * @param parameterId   呼吸をひもづけるパラメータID
	 * @param offset        呼吸を正弦波としたときの、波のオフセット
	 * @param peak          呼吸を正弦波としたときの、波の高さ
	 * @param cycle         呼吸を正弦波としたときの、波の周期
	 * @param weight        パラメータへの重み
	 */
    constructor(parameterId?: string, offset?: number, peak?: number, cycle?: number, weight?: number)
    parameterId?: string
    offset: number
    peak: number
    cycle: number
    weight: number
}
declare class CubismPose {
    /**
	 * インスタンスの作成
	 * @param pose3json pose3.jsonのデータ
	 * @return 作成されたインスタンス
	 */
    static create(pose3json: CubismSpec.PoseJSON): CubismPose
    /**
	 * モデルのパラメータの更新
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
    updateParameters(model: CubismModel, deltaTimeSeconds: number): void
    /**
	 * 表示を初期化
	 * @param model 対象のモデル
	 * @note 不透明度の初期値が0でないパラメータは、不透明度を１に設定する
	 */
    reset(model: CubismModel): void
    /**
	 * パーツの不透明度をコピー
	 *
	 * @param model 対象のモデル
	 */
    copyPartOpacities(model: CubismModel): void
    /**
	 * パーツのフェード操作を行う。
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 * @param beginIndex フェード操作を行うパーツグループの先頭インデックス
	 * @param partGroupCount フェード操作を行うパーツグループの個数
	 */
    doFade(model: CubismModel, deltaTimeSeconds: number, beginIndex: number, partGroupCount: number): void
    /**
	 * コンストラクタ
	 */
    constructor()
    _partGroups: PartData[]
    _partGroupCounts: number[]
    _fadeTimeSeconds: number
    _lastModel?: CubismModel
}
declare class PartData {
    /**
	 * コンストラクタ
	 */
    constructor(v?: PartData)
    /**
	 * =演算子のオーバーロード
	 */
    assignment(v: PartData): PartData
    /**
	 * 初期化
	 * @param model 初期化に使用するモデル
	 */
    initialize(model: CubismModel): void
    /**
	 * オブジェクトのコピーを生成する
	 */
    clone(): PartData
    partId: string
    parameterIndex: number
    partIndex: number
    link: PartData[]
}
/**
 * ユーザーデータインターフェース
 *
 * Jsonから読み込んだユーザーデータを記録しておくための構造体
 */
export interface CubismModelUserDataNode {
    targetType: string
    targetId: string
    value: string
}
declare class CubismModelUserData {
    /**
	 * インスタンスの作成
	 *
	 * @param json    userdata3.jsonが読み込まれているバッファ
	 * @param size      バッファのサイズ
	 * @return 作成されたインスタンス
	 */
    static create(json: CubismSpec.UserDataJSON, size: number): CubismModelUserData
    /**
	 * ArtMeshのユーザーデータのリストの取得
	 *
	 * @return ユーザーデータリスト
	 */
    getArtMeshUserDatas(): CubismModelUserDataNode[]
    /**
	 * userdata3.jsonのパース
	 *
	 * @param data    userdata3.jsonが読み込まれているバッファ
	 * @param size      バッファのサイズ
	 */
    parseUserData(data: CubismSpec.UserDataJSON, size: number): void
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 *
	 * ユーザーデータ構造体配列を解放する
	 */
    release(): void
    private _userDataNodes
    private _artMeshUserDataNode
}
declare class CubismVector2 {
    x: number
    y: number
    /**
	 * コンストラクタ
	 */
    constructor(x?: number, y?: number)
    /**
	 * ベクトルの加算
	 *
	 * @param vector2 加算するベクトル値
	 * @return 加算結果 ベクトル値
	 */
    add(vector2: CubismVector2): CubismVector2
    /**
	 * ベクトルの減算
	 *
	 * @param vector2 減算するベクトル値
	 * @return 減算結果 ベクトル値
	 */
    substract(vector2: CubismVector2): CubismVector2
    /**
	 * ベクトルの乗算
	 *
	 * @param vector2 乗算するベクトル値
	 * @return 乗算結果 ベクトル値
	 */
    multiply(vector2: CubismVector2): CubismVector2
    /**
	 * ベクトルの乗算(スカラー)
	 *
	 * @param scalar 乗算するスカラー値
	 * @return 乗算結果 ベクトル値
	 */
    multiplyByScaler(scalar: number): CubismVector2
    /**
	 * ベクトルの除算
	 *
	 * @param vector2 除算するベクトル値
	 * @return 除算結果 ベクトル値
	 */
    division(vector2: CubismVector2): CubismVector2
    /**
	 * ベクトルの除算(スカラー)
	 *
	 * @param scalar 除算するスカラー値
	 * @return 除算結果 ベクトル値
	 */
    divisionByScalar(scalar: number): CubismVector2
    /**
	 * ベクトルの長さを取得する
	 *
	 * @return ベクトルの長さ
	 */
    getLength(): number
    /**
	 * ベクトルの距離の取得
	 *
	 * @param a 点
	 * @return ベクトルの距離
	 */
    getDistanceWith(a: CubismVector2): number
    /**
	 * ドット積の計算
	 *
	 * @param a 値
	 * @return 結果
	 */
    dot(a: CubismVector2): number
    /**
	 * 正規化の適用
	 */
    normalize(): void
    /**
	 * 等しさの確認（等しいか？）
	 *
	 * 値が等しいか？
	 *
	 * @param rhs 確認する値
	 * @return true 値は等しい
	 * @return false 値は等しくない
	 */
    isEqual(rhs: CubismVector2): boolean
    /**
	 * 等しさの確認（等しくないか？）
	 *
	 * 値が等しくないか？
	 *
	 * @param rhs 確認する値
	 * @return true 値は等しくない
	 * @return false 値は等しい
	 */
    isNotEqual(rhs: CubismVector2): boolean
}
declare enum CubismPhysicsTargetType {
    CubismPhysicsTargetType_Parameter = 0
}
declare enum CubismPhysicsSource {
    CubismPhysicsSource_X = 0, // X軸の位置から
    CubismPhysicsSource_Y = 1, // Y軸の位置から
    CubismPhysicsSource_Angle = 2
}
/**
 * 物理演算のパラメータ情報
 */
export interface CubismPhysicsParameter {
    id: string
    targetType: CubismPhysicsTargetType
}
/**
 * 物理演算の正規化情報
 */
export interface CubismPhysicsNormalization {
    minimum: number
    maximum: number
    defalut: number
}
declare class CubismPhysicsParticle {
    constructor()
    initialPosition: CubismVector2
    mobility: number
    delay: number
    acceleration: number
    radius: number
    position: CubismVector2
    lastPosition: CubismVector2
    lastGravity: CubismVector2
    force: CubismVector2
    velocity: CubismVector2
}
declare class CubismPhysicsSubRig {
    inputCount: number
    outputCount: number
    particleCount: number
    baseInputIndex: number
    baseOutputIndex: number
    baseParticleIndex: number
    normalizationPosition: CubismPhysicsNormalization
    normalizationAngle: CubismPhysicsNormalization
}
/**
 * 正規化されたパラメータの取得関数の宣言
// 演算結果の移動値
// 演算結果の角度
// パラメータの値
// パラメータの最小値
// パラメータの最大値
// パラメータのデフォルト値
// 正規化された位置
// 正規化された角度
// 値が反転されているか？
// 重み
 */
export interface normalizedPhysicsParameterValueGetter {
    (targetTranslation: CubismVector2, targetAngle: {
        angle: number
    }, value: number, parameterMinimunValue: number, parameterMaximumValue: number, parameterDefaultValue: number, normalizationPosition: CubismPhysicsNormalization, normalizationAngle: CubismPhysicsNormalization, isInverted: boolean, weight: number): void
}
/**
 * 物理演算の値の取得関数の宣言
 * @param translation 移動値
 * @param particles 物理点のリスト
 * @param isInverted 値が反映されているか
 * @param parentGravity 重力
 * @return 値
 */
export interface physicsValueGetter {
    (translation: CubismVector2, particles: CubismPhysicsParticle[], particleIndex: number, isInverted: boolean, parentGravity: CubismVector2): number
}
/**
 * 物理演算のスケールの取得関数の宣言
 * @param translationScale 移動値のスケール
 * @param angleScale    角度のスケール
 * @return スケール値
 */
export interface physicsScaleGetter {
    (translationScale: CubismVector2, angleScale: number): number
}
declare class CubismPhysicsInput {
    source: CubismPhysicsParameter
    sourceParameterIndex: number
    weight: number
    type: number
    reflect: boolean
    getNormalizedParameterValue: normalizedPhysicsParameterValueGetter
}
declare class CubismPhysicsOutput {
    destination: CubismPhysicsParameter
    destinationParameterIndex: number
    vertexIndex: number
    translationScale: CubismVector2
    angleScale: number
    weight: number
    type: CubismPhysicsSource
    reflect: boolean
    valueBelowMinimum: number
    valueExceededMaximum: number
    getValue: physicsValueGetter
    getScale: physicsScaleGetter
}
declare class CubismPhysicsRig {
    constructor()
    subRigCount: number
    settings: CubismPhysicsSubRig[]
    inputs: CubismPhysicsInput[]
    outputs: CubismPhysicsOutput[]
    particles: CubismPhysicsParticle[]
    gravity: CubismVector2
    wind: CubismVector2
    fps: number
}
declare class CubismPhysics {
    /**
	 * インスタンスの作成
	 * @param json    physics3.jsonが読み込まれているバッファ
	 * @return 作成されたインスタンス
	 */
    static create(json: CubismSpec.PhysicsJSON): CubismPhysics
    /**
	 * インスタンスを破棄する
	 * @param physics 破棄するインスタンス
	 */
    static delete(physics: CubismPhysics): void
    /**
	 * physics3.jsonをパースする。
	 * @param physicsJson physics3.jsonが読み込まれているバッファ
	 */
    parse(physicsJson: CubismSpec.PhysicsJSON): void
    /**
	 * 現在のパラメータ値で物理演算が安定化する状態を演算する。
	 * @param model 物理演算の結果を適用するモデル
	 */
    stabilization(model: CubismModel): void
    /**
	 * 物理演算の評価
	 *
	 * Pendulum interpolation weights
	 *
	 * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。
	 * The result of the pendulum calculation is saved and
	 * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.
	 *
	 * 図で示すと[1]と[2]で補間されます。
	 * The figure shows the interpolation between [1] and [2].
	 *
	 * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。
	 * The weight of the interpolation are determined by the current time seen between
	 * the latest pendulum calculation timing and the next timing.
	 *
	 * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。
	 * Figure shows the weight of position (3) as seen between [2] and [4].
	 *
	 * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。
	 * As an interpretation, the pendulum calculation and weights are misaligned.
	 *
	 * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。
	 * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.
	 *
	 * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。
	 * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.
	 *
	 * ------------ time -------------->
	 *
	 *                 |+++++|------| <- weight
	 * ==[1]====#=====[2]---(3)----(4)
	 *          ^ output contents
	 *
	 * 1:_previousRigOutputs
	 * 2:_currentRigOutputs
	 * 3:_currentRemainTime (now rendering)
	 * 4:next particles timing
	 * @param model 物理演算の結果を適用するモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
    evaluate(model: CubismModel, deltaTimeSeconds: number): void
    /**
	 * 物理演算結果の適用
	 * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。
	 * @param model 物理演算の結果を適用するモデル
	 * @param weight 最新結果の重み
	 */
    interpolate(model: CubismModel, weight: number): void
    /**
	 * オプションの設定
	 * @param options オプション
	 */
    setOptions(options: Options): void
    /**
	 * オプションの取得
	 * @return オプション
	 */
    getOption(): Options
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * 初期化する
	 */
    initialize(): void
    _physicsRig: CubismPhysicsRig
    _options: Options
    _currentRigOutputs: PhysicsOutput[]
    _previousRigOutputs: PhysicsOutput[]
    _currentRemainTime: number
    _parameterCaches: Float32Array
    _parameterInputCaches: Float32Array
}
declare class Options {
    constructor()
    gravity: CubismVector2
    wind: CubismVector2
}
declare class PhysicsOutput {
    outputs: number[]
}
declare class csmRect {
    /**
	 * コンストラクタ
	 * @param x 左端X座標
	 * @param y 上端Y座標
	 * @param w 幅
	 * @param h 高さ
	 */
    constructor(x?: number, y?: number, w?: number, h?: number)
    /**
	 * 矩形中央のX座標を取得する
	 */
    getCenterX(): number
    /**
	 * 矩形中央のY座標を取得する
	 */
    getCenterY(): number
    /**
	 * 右側のX座標を取得する
	 */
    getRight(): number
    /**
	 * 下端のY座標を取得する
	 */
    getBottom(): number
    /**
	 * 矩形に値をセットする
	 * @param r 矩形のインスタンス
	 */
    setRect(r: csmRect): void
    /**
	 * 矩形中央を軸にして縦横を拡縮する
	 * @param w 幅方向に拡縮する量
	 * @param h 高さ方向に拡縮する量
	 */
    expand(w: number, h: number): void
    x: number
    y: number
    width: number
    height: number
}
declare class CubismClippingManager_WebGL {
    /**
	 * カラーチャンネル（RGBA）のフラグを取得する
	 * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）
	 */
    getChannelFlagAsColor(channelNo: number): CubismTextureColor
    /**
	 * テンポラリのレンダーテクスチャのアドレスを取得する
	 * FrameBufferObjectが存在しない場合、新しく生成する
	 *
	 * @return レンダーテクスチャの配列
	 */
    getMaskRenderTexture(): WebGLFramebuffer[]
    /**
	 * WebGLレンダリングコンテキストを設定する
	 * @param gl WebGLレンダリングコンテキスト
	 */
    setGL(gl: WebGLRenderingContext): void
    /**
	 * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する
	 * @param model モデルのインスタンス
	 * @param clippingContext クリッピングマスクのコンテキスト
	 */
    calcClippedDrawTotalBounds(model: CubismModel, clippingContext: CubismClippingContext): void
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * マネージャの初期化処理
	 * クリッピングマスクを使う描画オブジェクトの登録を行う
	 * @param model モデルのインスタンス
	 * @param drawableCount 描画オブジェクトの数
	 * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのインデックスのリスト
	 * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数
	 * @param renderTextureCount バッファの生成数
	 */
    initialize(model: CubismModel, drawableCount: number, drawableMasks: Int32Array[], drawableMaskCounts: Int32Array, renderTextureCount: number): void
    /**
	 * クリッピングコンテキストを作成する。モデル描画時に実行する。
	 * @param model モデルのインスタンス
	 * @param renderer レンダラのインスタンス
	 */
    setupClippingContext(model: CubismModel, renderer: CubismRenderer_WebGL): void
    /**
	 * 既にマスクを作っているかを確認
	 * 作っている様であれば該当するクリッピングマスクのインスタンスを返す
	 * 作っていなければNULLを返す
	 * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト
	 * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数
	 * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す
	 */
    findSameClip(drawableMasks: Int32Array, drawableMaskCounts: number): CubismClippingContext | null
    /**
	 * クリッピングコンテキストを配置するレイアウト
	 * 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする
	 * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。
	 *
	 * @param usingClipCount 配置するクリッピングコンテキストの数
	 */
    setupLayoutBounds(usingClipCount: number): void
    /**
	 * カラーバッファを取得する
	 * @return カラーバッファ
	 */
    getColorBuffer(): WebGLTexture[] | undefined
    /**
	 * 画面描画に使用するクリッピングマスクのリストを取得する
	 * @return 画面描画に使用するクリッピングマスクのリスト
	 */
    getClippingContextListForDraw(): (CubismClippingContext | null)[]
    /**
	 * マスクの合計数をカウント
	 * @returns
	 */
    getClippingMaskCount(): number
    /**
	 * クリッピングマスクバッファのサイズを設定する
	 * @param size クリッピングマスクバッファのサイズ
	 */
    setClippingMaskBufferSize(size: number): void
    /**
	 * クリッピングマスクバッファのサイズを取得する
	 * @return クリッピングマスクバッファのサイズ
	 */
    getClippingMaskBufferSize(): number
    /**
	 * このバッファのレンダーテクスチャの枚数を取得する
	 * @return このバッファのレンダーテクスチャの枚数
	 */
    getRenderTextureCount(): number
    _currentMaskRenderTexture: WebGLFramebuffer | null
    _maskRenderTextures?: WebGLFramebuffer[]
    _maskColorBuffers?: WebGLTexture[]
    _currentFrameNo: number
    _channelColors: CubismTextureColor[]
    _maskTexture?: CubismRenderTextureResource
    _clippingContextListForMask: CubismClippingContext[]
    _clippingContextListForDraw: (CubismClippingContext | null)[]
    _clippingMaskBufferSize: number
    _renderTextureCount: number
    private _tmpMatrix
    private _tmpMatrixForMask
    private _tmpMatrixForDraw
    private _tmpBoundsOnModel
    private _clearedFrameBufferflags?
    gl: WebGLRenderingContext
}
declare class CubismRenderTextureResource {
    /**
	 * 引数付きコンストラクタ
	 * @param frameNo レンダラーのフレーム番号
	 * @param texture テクスチャのアドレス
	 */
    constructor(frameNo: number, texture: WebGLFramebuffer[])
    frameNo: number
    textures: WebGLFramebuffer[]
}
declare class CubismClippingContext {
    /**
	 * 引数付きコンストラクタ
	 */
    constructor(manager: CubismClippingManager_WebGL, clippingDrawableIndices: Int32Array, clipCount: number)
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * このマスクにクリップされる描画オブジェクトを追加する
	 *
	 * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス
	 */
    addClippedDrawable(drawableIndex: number): void
    /**
	 * このマスクを管理するマネージャのインスタンスを取得する
	 * @return クリッピングマネージャのインスタンス
	 */
    getClippingManager(): CubismClippingManager_WebGL
    setGl(gl: WebGLRenderingContext): void
    _isUsing: boolean
    readonly _clippingIdList: Int32Array
    _clippingIdCount: number
    _layoutChannelNo: number
    _layoutBounds: csmRect
    _allClippedDrawRect: csmRect
    _matrixForMask: CubismMatrix44
    _matrixForDraw: CubismMatrix44
    _clippedDrawableIndexList: number[]
    _bufferIndex: number
    private _owner
}
declare class CubismRendererProfile_WebGL {
    private setGlEnable
    private setGlEnableVertexAttribArray
    save(): void
    restore(): void
    setGl(gl: WebGLRenderingContext): void
    constructor()
    private _lastArrayBufferBinding
    private _lastElementArrayBufferBinding
    private _lastProgram
    private _lastActiveTexture
    private _lastTexture0Binding2D
    private _lastTexture1Binding2D
    private _lastVertexAttribArrayEnabled
    private _lastScissorTest
    private _lastBlend
    private _lastStencilTest
    private _lastDepthTest
    private _lastCullFace
    private _lastFrontFace
    private _lastColorMask
    private _lastBlending
    private _lastFBO
    private _lastViewport
    gl: WebGLRenderingContext
}
declare class CubismRenderer_WebGL extends CubismRenderer {
    /**
	 * レンダラの初期化処理を実行する
	 * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
	 *
	 * @param model モデルのインスタンス
	 * @param maskBufferCount バッファの生成数
	 */
    initialize(model: CubismModel, maskBufferCount?: number): void
    /**
	 * WebGLテクスチャのバインド処理
	 * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする
	 * @param modelTextureNo セットするモデルテクスチャの番号
	 * @param glTextureNo WebGLテクスチャの番号
	 */
    bindTexture(modelTextureNo: number, glTexture: WebGLTexture): void
    /**
	 * WebGLにバインドされたテクスチャのリストを取得する
	 * @return テクスチャのリスト
	 */
    getBindedTextures(): Record<number, WebGLTexture>
    /**
	 * クリッピングマスクバッファのサイズを設定する
	 * マスク用のFrameBufferを破棄、再作成する為処理コストは高い
	 * @param size クリッピングマスクバッファのサイズ
	 */
    setClippingMaskBufferSize(size: number): void
    /**
	 * クリッピングマスクバッファのサイズを取得する
	 * @return クリッピングマスクバッファのサイズ
	 */
    getClippingMaskBufferSize(): number
    /**
	 * レンダーテクスチャの枚数を取得する
	 * @return レンダーテクスチャの枚数
	 */
    getRenderTextureCount(): number
    /**
	 * コンストラクタ
	 */
    constructor()
    /**
	 * デストラクタ相当の処理
	 */
    release(): void
    /**
	 * モデルを描画する実際の処理
	 */
    doDrawModel(): void
    /**
	 * [オーバーライド]
	 * 描画オブジェクト（アートメッシュ）を描画する。
	 * ポリゴンメッシュとテクスチャ番号をセットで渡す。
	 * @param textureNo 描画するテクスチャ番号
	 * @param indexCount 描画オブジェクトのインデックス値
	 * @param vertexCount ポリゴンメッシュの頂点数
	 * @param indexArray ポリゴンメッシュのインデックス配列
	 * @param vertexArray ポリゴンメッシュの頂点配列
	 * @param uvArray uv配列
	 * @param opacity 不透明度
	 * @param colorBlendMode カラー合成タイプ
	 * @param invertedMask マスク使用時のマスクの反転使用
	 */
    drawMesh(textureNo: number, indexCount: number, vertexCount: number, indexArray: Uint16Array, vertexArray: Float32Array, uvArray: Float32Array, multiplyColor: CubismTextureColor, screenColor: CubismTextureColor, opacity: number, colorBlendMode: CubismBlendMode, invertedMask: boolean): void
    protected saveProfile(): void
    protected restoreProfile(): void
    /**
	 * レンダラが保持する静的なリソースを解放する
	 * WebGLの静的なシェーダープログラムを解放する
	 */
    static doStaticRelease(): void
    /**
	 * レンダーステートを設定する
	 * @param fbo アプリケーション側で指定しているフレームバッファ
	 * @param viewport ビューポート
	 */
    setRenderState(fbo: WebGLFramebuffer, viewport: number[]): void
    /**
	 * 描画開始時の追加処理
	 * モデルを描画する前にクリッピングマスクに必要な処理を実装している
	 */
    preDraw(): void
    /**
	 * マスクテクスチャに描画するクリッピングコンテキストをセットする
	 */
    setClippingContextBufferForMask(clip: CubismClippingContext | null): void
    /**
	 * マスクテクスチャに描画するクリッピングコンテキストを取得する
	 * @return マスクテクスチャに描画するクリッピングコンテキスト
	 */
    getClippingContextBufferForMask(): CubismClippingContext | null
    /**
	 * 画面上に描画するクリッピングコンテキストをセットする
	 */
    setClippingContextBufferForDraw(clip: CubismClippingContext | null): void
    /**
	 * 画面上に描画するクリッピングコンテキストを取得する
	 * @return 画面上に描画するクリッピングコンテキスト
	 */
    getClippingContextBufferForDraw(): CubismClippingContext | null
    /**
	 * glの設定
	 */
    startUp(gl: WebGLRenderingContext): void
    _textures: Record<number, WebGLTexture>
    _sortedDrawableIndexList: number[]
    _clippingManager: CubismClippingManager_WebGL
    _clippingContextBufferForMask: CubismClippingContext | null
    _clippingContextBufferForDraw: CubismClippingContext | null
    _rendererProfile: CubismRendererProfile_WebGL
    firstDraw: boolean
    _bufferData: {
        vertex: WebGLBuffer | null,
        uv: WebGLBuffer | null,
        index: WebGLBuffer | null
    }
    _extension: any
    gl: WebGLRenderingContext
}
declare class CubismEyeBlink {
    /**
	 * インスタンスを作成する
	 * @param modelSetting モデルの設定情報
	 * @return 作成されたインスタンス
	 * @note 引数がNULLの場合、パラメータIDが設定されていない空のインスタンスを作成する。
	 */
    static create(modelSetting: CubismModelSettingsJson): CubismEyeBlink
    /**
	 * まばたきの間隔の設定
	 * @param blinkingInterval まばたきの間隔の時間[秒]
	 */
    setBlinkingInterval(blinkingInterval: number): void
    /**
	 * まばたきのモーションの詳細設定
	 * @param closing   まぶたを閉じる動作の所要時間[秒]
	 * @param closed    まぶたを閉じている動作の所要時間[秒]
	 * @param opening   まぶたを開く動作の所要時間[秒]
	 */
    setBlinkingSetting(closing: number, closed: number, opening: number): void
    /**
	 * まばたきさせるパラメータIDのリストの設定
	 * @param parameterIds パラメータのIDのリスト
	 */
    setParameterIds(parameterIds: string[]): void
    /**
	 * まばたきさせるパラメータIDのリストの取得
	 * @return パラメータIDのリスト
	 */
    getParameterIds(): string[]
    /**
	 * モデルのパラメータの更新
	 * @param model 対象のモデル
	 * @param deltaTimeSeconds デルタ時間[秒]
	 */
    updateParameters(model: CubismModel, deltaTimeSeconds: number): void
    /**
	 * コンストラクタ
	 * @param modelSetting モデルの設定情報
	 */
    constructor(modelSetting: CubismModelSettingsJson)
    /**
	 * 次の瞬きのタイミングの決定
	 *
	 * @return 次のまばたきを行う時刻[秒]
	 */
    determinNextBlinkingTiming(): number
    _blinkingState: number
    _parameterIds: string[]
    _nextBlinkingTime: number
    _stateStartTimeSeconds: number
    _blinkingIntervalSeconds: number
    _blinkingIntervalRandomSeconds: number
    _closingSeconds: number
    _closedSeconds: number
    _openingSeconds: number
    _userTimeSeconds: number
    /**
	 * IDで指定された目のパラメータが、0のときに閉じるなら true 、1の時に閉じるなら false 。
	 */
    static readonly CloseIfZero: boolean
}
export declare class Cubism4InternalModel extends InternalModel {
    settings: Cubism4ModelSettings
    coreModel: CubismModel
    motionManager: Cubism4MotionManager
    lipSync: boolean
    breath: CubismBreath
    eyeBlink?: CubismEyeBlink
    pose?: CubismPose
    physics?: CubismPhysics
    userData?: CubismModelUserData
    renderer: CubismRenderer_WebGL
    idParamAngleX: string
    idParamAngleY: string
    idParamAngleZ: string
    idParamEyeBallX: string
    idParamEyeBallY: string
    idParamBodyAngleX: string
    idParamBreath: string
    idParamMouthForm: string
    /**
	 * The model's internal scale, defined in the moc3 file.
	 */
    readonly pixelsPerUnit: number
    /**
	 * Matrix that scales by {@link pixelsPerUnit}, and moves the origin from top-left to center.
	 *
	 * FIXME: This shouldn't be named as "centering"...
	 */
    protected centeringTransform: Matrix
    constructor(coreModel: CubismModel, settings: Cubism4ModelSettings, options?: InternalModelOptions)
    protected init(): void
    protected getSize(): [
        number,
        number
    ]
    protected getLayout(): CommonLayout
    protected setupLayout(): void
    updateWebGLContext(gl: WebGLRenderingContext, glContextID: number): void
    bindTexture(index: number, texture: WebGLTexture): void
    protected getHitAreaDefs(): CommonHitArea[]
    getDrawableIDs(): string[]
    getDrawableIndex(id: string): number
    getDrawableVertices(drawIndex: number | string): Float32Array
    updateTransform(transform: Matrix): void
    update(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void
    updateFocus(): void
    updateFacialEmotion(mouthForm: number): void
    updateNaturalMovements(dt: DOMHighResTimeStamp, now: DOMHighResTimeStamp): void
    draw(gl: WebGLRenderingContext): void
    destroy(): void
    setBlinkParam(blinkParam: Partial<BlinkParam>): void
}
export interface CubismStartupOption {
    logFunction: Live2DCubismCore.csmLogFunction
    loggingLevel: LogLevel
}
declare enum LogLevel {
    LogLevel_Verbose = 0, // 詳細ログ
    LogLevel_Debug = 1, // デバッグログ
    LogLevel_Info = 2, // Infoログ
    LogLevel_Warning = 3, // 警告ログ
    LogLevel_Error = 4, // エラーログ
    LogLevel_Off = 5
}
/**
 * Promises that the Cubism 4 framework is ready to work.
 * @return Promise that resolves if the startup has succeeded, rejects if failed.
 */
export declare function cubism4Ready(): Promise<void>
/**
 * Starts up Cubism 4 framework.
 */
export declare function startUpCubism4(options?: CubismStartupOption): void

export {}
